//! Opset 7 compliance tests.
//!
//! Auto-generated by gen_rust_tests.py. Edit the generator, not this file.

use super::helpers::*;

#[test]
fn acos() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "acos");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Acos "acos1"
      Inputs:
        acos_input: F32[2, 3, 4]
      Outputs:
        acos1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn add() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "add");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Add "add1"
      Inputs:
        add_a: F32[2, 3, 4]
        add_b: F32[2, 3, 4]
      Outputs:
        add1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn and_op() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "and");
    insta::assert_snapshot!(format!("{node}"), @r#"
    And "and1"
      Inputs:
        and_a: Bool[2, 3, 4]
        and_b: Bool[2, 3, 4]
      Outputs:
        and1_out1: Bool[2, 3, 4]
    "#);
}

#[test]
fn asin() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "asin");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Asin "asin1"
      Inputs:
        asin_input: F32[2, 3, 4]
      Outputs:
        asin1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn atan() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "atan");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Atan "atan1"
      Inputs:
        atan_input: F32[2, 3, 4]
      Outputs:
        atan1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn cos() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "cos");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Cos "cos1"
      Inputs:
        cos_input: F32[2, 3, 4]
      Outputs:
        cos1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn div() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "div");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Div "div1"
      Inputs:
        div_a: F32[2, 3, 4]
        div_b: F32[2, 3, 4]
      Outputs:
        div1_out1: F32[2, 3, 4]
    "#);
}

/// Dropout is eliminated during post-processing (no-op).
/// Verify the model parses without error.
#[test]
fn dropout() {
    let _graph = load_model("opset_07.onnx");
}

#[test]
fn equal() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "equal");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Equal "equal1"
      Inputs:
        equal_a: F32[2, 3, 4]
        equal_b: F32[2, 3, 4]
      Outputs:
        equal1_out1: Bool[?, ?, ?]
    "#);
}

#[test]
fn gru() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "gru");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Gru "gru1"
      Inputs:
        gru_input: F32[1, 2, 3]
        _: F32[1, 12, 3] [static(0)]
        _: F32[1, 12, 4] [static(1)]
      Outputs:
        gru1_out1: F32[?, ?, ?, ?]
      Config:
        GruConfig {
            input_size: 3,
            hidden_size: 4,
            direction: Forward,
            has_bias: false,
            has_initial_h: false,
            batch_first: false,
            clip: None,
            linear_before_reset: false,
            gate_activation: Sigmoid,
            hidden_activation: Tanh,
            activation_alpha: None,
            activation_beta: None,
        }
    "#);
}

#[test]
fn greater() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "greater");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Greater "greater1"
      Inputs:
        greater_a: F32[2, 3, 4]
        greater_b: F32[2, 3, 4]
      Outputs:
        greater1_out1: Bool[?, ?, ?]
    "#);
}

#[test]
fn lstm() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "lstm");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Lstm "lstm1"
      Inputs:
        lstm_input: F32[1, 2, 3]
        _: F32[1, 16, 3] [static(2)]
        _: F32[1, 16, 4] [static(3)]
      Outputs:
        lstm1_out1: F32[?, ?, ?, ?]
      Config:
        LstmConfig {
            input_size: 3,
            hidden_size: 4,
            direction: Forward,
            has_bias: false,
            has_initial_h: false,
            has_initial_c: false,
            has_peephole: false,
            batch_first: false,
            clip: None,
            input_forget: false,
            gate_activation: Sigmoid,
            cell_activation: Tanh,
            hidden_activation: Tanh,
        }
    "#);
}

#[test]
fn less() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "less");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Less "less1"
      Inputs:
        less_a: F32[2, 3, 4]
        less_b: F32[2, 3, 4]
      Outputs:
        less1_out1: Bool[?, ?, ?]
    "#);
}

#[test]
fn mul() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "mul");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Mul "mul1"
      Inputs:
        mul_a: F32[2, 3, 4]
        mul_b: F32[2, 3, 4]
      Outputs:
        mul1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn or_op() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "or");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Or "or1"
      Inputs:
        or_a: Bool[2, 3, 4]
        or_b: Bool[2, 3, 4]
      Outputs:
        or1_out1: Bool[2, 3, 4]
    "#);
}

#[test]
fn p_relu() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "prelu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    PRelu "prelu1"
      Inputs:
        prelu_input: F32[2, 3, 4]
        _: F32[1] [static(4)]
      Outputs:
        prelu1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn pow() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "pow");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Pow "pow1"
      Inputs:
        pow_a: F32[2, 3, 4]
        pow_b: F32[2, 3, 4]
      Outputs:
        pow1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn sin() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "sin");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sin "sin1"
      Inputs:
        sin_input: F32[2, 3, 4]
      Outputs:
        sin1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn sub() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "sub");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sub "sub1"
      Inputs:
        sub_a: F32[2, 3, 4]
        sub_b: F32[2, 3, 4]
      Outputs:
        sub1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn tan() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "tan");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Tan "tan1"
      Inputs:
        tan_input: F32[2, 3, 4]
      Outputs:
        tan1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn xor_op() {
    let graph = load_model("opset_07.onnx");
    let node = find_node(&graph, "xor");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Xor "xor1"
      Inputs:
        xor_a: Bool[2, 3, 4]
        xor_b: Bool[2, 3, 4]
      Outputs:
        xor1_out1: Bool[2, 3, 4]
    "#);
}

/// Ops that require min_opset > 7: AveragePool, BatchNormalization, Gemm
#[test]
fn unsupported_ops_fail() {
    let result = load_model_result("opset_07_unsupported.onnx");
    assert!(result.is_err(), "expected parse failure for unsupported ops at opset 7");
}

