//! Opset 18 compliance tests.
//!
//! Auto-generated by gen_rust_tests.py. Edit the generator, not this file.

use super::helpers::*;

#[test]
fn bitwise_and() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "bitwiseand");
    insta::assert_snapshot!(format!("{node}"), @r#"
    BitwiseAnd "bitwiseand1"
      Inputs:
        bitwiseand_a: I32[2, 3, 4]
        bitwiseand_b: I32[2, 3, 4]
      Outputs:
        bitwiseand1_out1: I32[2, 3, 4]
    "#);
}

#[test]
fn bitwise_not() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "bitwisenot");
    insta::assert_snapshot!(format!("{node}"), @r#"
    BitwiseNot "bitwisenot1"
      Inputs:
        bitwisenot_input: I32[2, 3, 4]
      Outputs:
        bitwisenot1_out1: I32[2, 3, 4]
    "#);
}

#[test]
fn bitwise_or() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "bitwiseor");
    insta::assert_snapshot!(format!("{node}"), @r#"
    BitwiseOr "bitwiseor1"
      Inputs:
        bitwiseor_a: I32[2, 3, 4]
        bitwiseor_b: I32[2, 3, 4]
      Outputs:
        bitwiseor1_out1: I32[2, 3, 4]
    "#);
}

#[test]
fn bitwise_xor() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "bitwisexor");
    insta::assert_snapshot!(format!("{node}"), @r#"
    BitwiseXor "bitwisexor1"
      Inputs:
        bitwisexor_a: I32[2, 3, 4]
        bitwisexor_b: I32[2, 3, 4]
      Outputs:
        bitwisexor1_out1: I32[2, 3, 4]
    "#);
}

#[test]
fn group_normalization() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "groupnormalization");
    insta::assert_snapshot!(format!("{node}"), @r#"
    GroupNormalization "groupnormalization1"
      Inputs:
        groupnormalization_input: F32[1, 4, 3, 3]
        _: F32[4] [static(0)]
        _: F32[4] [static(1)]
      Outputs:
        groupnormalization1_out1: F32[1, 4, 3, 3]
      Config:
        GroupNormConfig {
            num_groups: 2,
            epsilon: 9.999999747378752e-6,
            full_precision: true,
        }
    "#);
}

#[test]
fn mish() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "mish");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Mish "mish1"
      Inputs:
        mish_input: F32[2, 3, 4]
      Outputs:
        mish1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn pad() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "pad");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Pad "pad1"
      Inputs:
        pad_input: F32[2, 3]
        _: I64[4] [static(2)]
        _: Scalar(F32) [static(3)]
      Outputs:
        pad1_out1: F32[2, 3]
      Config:
        PadConfig {
            pads: Static(
                [
                    1,
                    1,
                    0,
                    0,
                ],
            ),
            constant_value: Static(
                0.0,
            ),
            mode: Constant,
        }
    "#);
}

#[test]
fn reduce_l1() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "reducel1");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceL1 "reducel11"
      Inputs:
        reducel1_input: F32[2, 3, 4]
        _: I64[1] [static(4)]
      Outputs:
        reducel11_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[test]
fn reduce_l2() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "reducel2");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceL2 "reducel21"
      Inputs:
        reducel2_input: F32[2, 3, 4]
        _: I64[1] [static(5)]
      Outputs:
        reducel21_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[test]
fn reduce_log_sum() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "reducelogsum");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceLogSum "reducelogsum1"
      Inputs:
        reducelogsum_input: F32[2, 3, 4]
        _: I64[1] [static(6)]
      Outputs:
        reducelogsum1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[test]
fn reduce_log_sum_exp() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "reducelogsumexp");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceLogSumExp "reducelogsumexp1"
      Inputs:
        reducelogsumexp_input: F32[2, 3, 4]
        _: I64[1] [static(7)]
      Outputs:
        reducelogsumexp1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[test]
fn reduce_max() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "reducemax");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceMax "reducemax1"
      Inputs:
        reducemax_input: F32[2, 3, 4]
        _: I64[1] [static(8)]
      Outputs:
        reducemax1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[test]
fn reduce_mean() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "reducemean");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceMean "reducemean1"
      Inputs:
        reducemean_input: F32[2, 3, 4]
        _: I64[1] [static(9)]
      Outputs:
        reducemean1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[test]
fn reduce_min() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "reducemin");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceMin "reducemin1"
      Inputs:
        reducemin_input: F32[2, 3, 4]
        _: I64[1] [static(10)]
      Outputs:
        reducemin1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[test]
fn reduce_prod() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "reduceprod");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceProd "reduceprod1"
      Inputs:
        reduceprod_input: F32[2, 3, 4]
        _: I64[1] [static(11)]
      Outputs:
        reduceprod1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[test]
fn reduce_sum_square() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "reducesumsquare");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceSumSquare "reducesumsquare1"
      Inputs:
        reducesumsquare_input: F32[2, 3, 4]
        _: I64[1] [static(12)]
      Outputs:
        reducesumsquare1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[test]
fn resize() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "resize");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Resize "resize1"
      Inputs:
        resize_input: F32[1, 1, 2, 2]
        _: F32[0] [static(13)]
        _: F32[0] [static(14)]
        _: I64[4] [static(15)]
      Outputs:
        resize1_out1: F32[1, 1, 2, 2]
      Config:
        ResizeConfig {
            mode: Nearest,
            scales: None,
            sizes: Some(
                Static(
                    [
                        4,
                        4,
                    ],
                ),
            ),
            coordinate_transformation_mode: "half_pixel",
            cubic_coeff_a: -0.75,
            nearest_mode: "round_prefer_floor",
            exclude_outside: 0,
            extrapolation_value: 0.0,
            antialias: 0,
        }
    "#);
}

#[test]
fn scatter_elements() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "scatterelements");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ScatterElements "scatterelements1"
      Inputs:
        scatterelements_input: F32[3, 3]
        constant17_out1: I64[1, 3] [constant]
        scatterelements_updates: F32[1, 3]
      Outputs:
        scatterelements1_out1: F32[3, 3]
      Config:
        ScatterElementsConfig {
            axis: 0,
            reduction: None,
        }
    "#);
}

#[test]
fn scatter_nd() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "scatternd");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ScatterND "scatternd1"
      Inputs:
        scatternd_input: F32[4, 4]
        constant18_out1: I64[2, 1] [constant]
        scatternd_updates: F32[2, 4]
      Outputs:
        scatternd1_out1: F32[4, 4]
      Config:
        ScatterNDConfig {
            reduction: None,
        }
    "#);
}

#[test]
fn split() {
    let graph = load_model("opset_18.onnx");
    let node = find_node(&graph, "split");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Split "split1"
      Inputs:
        split_input: F32[2, 6]
        _: I64[2] [static(18)]
      Outputs:
        split1_out1: F32[2, 3]
        split1_out2: F32[2, 3]
      Config:
        SplitConfig {
            axis: 1,
            split_size: None,
            split_sizes: Some(
                Static(
                    [
                        3,
                        3,
                    ],
                ),
            ),
            num_outputs: None,
        }
    "#);
}

