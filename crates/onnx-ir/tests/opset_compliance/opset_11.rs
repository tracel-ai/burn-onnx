//! Opset 11 compliance tests.
//!
//! Auto-generated by gen_rust_tests.py. Edit the generator, not this file.

use super::helpers::*;
use rstest::*;

#[fixture]
#[once]
fn graph() -> OnnxGraph {
    load_model("opset_11.onnx")
}

#[rstest]
fn arg_max(graph: &OnnxGraph) {
    let node = find_node(graph, "argmax");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ArgMax "argmax1"
      Inputs:
        argmax_input: F32[2, 3, 4]
      Outputs:
        argmax1_out1: I64[?, ?, ?]
      Config:
        ArgMaxConfig {
            axis: 1,
            keepdims: true,
        }
    "#);
}

#[rstest]
fn arg_min(graph: &OnnxGraph) {
    let node = find_node(graph, "argmin");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ArgMin "argmin1"
      Inputs:
        argmin_input: F32[2, 3, 4]
      Outputs:
        argmin1_out1: I64[?, ?, ?]
      Config:
        ArgMinConfig {
            axis: 1,
            keepdims: true,
        }
    "#);
}

#[rstest]
fn average_pool(graph: &OnnxGraph) {
    let node = find_node(graph, "averagepool2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    AveragePool2d "averagepool2d1"
      Inputs:
        averagepool_input: F32[1, 3, 8, 8]
      Outputs:
        averagepool2d1_out1: F32[?, ?, ?, ?]
      Config:
        AvgPool2dConfig {
            kernel_size: [
                2,
                2,
            ],
            strides: [
                2,
                2,
            ],
            padding: Valid,
            count_include_pad: false,
            dilation: [
                1,
                1,
            ],
            ceil_mode: false,
            auto_pad: NotSet,
        }
    "#);
}

#[rstest]
fn bit_shift(graph: &OnnxGraph) {
    let node = find_node(graph, "bitshift");
    insta::assert_snapshot!(format!("{node}"), @r#"
    BitShift "bitshift1"
      Inputs:
        bitshift_a: U32[2, 3]
        bitshift_b: U32[2, 3]
      Outputs:
        bitshift1_out1: U32[2, 3]
      Config:
        BitShiftConfig {
            direction: Left,
        }
    "#);
}

#[rstest]
fn clip(graph: &OnnxGraph) {
    let node = find_node(graph, "clip");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Clip "clip1"
      Inputs:
        clip_input: F32[2, 3, 4]
        _: ScalarNative(F32) [static(0)]
        _: ScalarNative(F32) [static(1)]
      Outputs:
        clip1_out1: F32[2, 3, 4]
      Config:
        ClipConfig {
            min: Some(
                Static(
                    0.0,
                ),
            ),
            max: Some(
                Static(
                    6.0,
                ),
            ),
        }
    "#);
}

#[rstest]
fn concat(graph: &OnnxGraph) {
    let node = find_node(graph, "concat");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Concat "concat1"
      Inputs:
        concat_a: F32[2, 3]
        concat_b: F32[2, 3]
      Outputs:
        concat1_out1: F32[?, ?]
      Config:
        ConcatConfig {
            axis: 0,
        }
    "#);
}

#[rstest]
fn constant(graph: &OnnxGraph) {
    let node = find_node(graph, "constant");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Constant "constant6"
      Inputs:
        _: I64[2] [static(5)]
      Outputs:
        constant6_out1: I64[2] [constant]
    "#);
}

#[rstest]
fn conv(graph: &OnnxGraph) {
    let node = find_node(graph, "conv2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Conv2d "conv2d1"
      Inputs:
        conv_input: F32[1, 3, 5, 5]
        _: F32[2, 3, 3, 3] [static(2)]
      Outputs:
        conv2d1_out1: F32[1, 2, 3, 3]
      Config:
        Conv2dConfig {
            kernel_size: [
                3,
                3,
            ],
            stride: [
                1,
                1,
            ],
            padding: Valid,
            dilation: [
                1,
                1,
            ],
            groups: 1,
            auto_pad: NotSet,
        }
    "#);
}

#[rstest]
fn conv_transpose(graph: &OnnxGraph) {
    let node = find_node(graph, "convtranspose2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ConvTranspose2d "convtranspose2d1"
      Inputs:
        convtranspose_input: F32[1, 3, 5, 5]
        _: F32[3, 2, 3, 3] [static(3)]
      Outputs:
        convtranspose2d1_out1: F32[1, 3, 5, 5]
      Config:
        ConvTranspose2dConfig {
            kernel_size: [
                3,
                3,
            ],
            stride: [
                1,
                1,
            ],
            dilation: [
                1,
                1,
            ],
            padding: [
                0,
                0,
            ],
            padding_out: [
                0,
                0,
            ],
            groups: 1,
        }
    "#);
}

#[rstest]
fn cum_sum(graph: &OnnxGraph) {
    let node = find_node(graph, "cumsum");
    insta::assert_snapshot!(format!("{node}"), @r#"
    CumSum "cumsum1"
      Inputs:
        cumsum_input: F32[2, 3]
        _: ScalarNative(I32) [static(4)]
      Outputs:
        cumsum1_out1: F32[2, 3]
      Config:
        CumSumConfig {
            axis: Static(
                1,
            ),
            exclusive: false,
            reverse: false,
        }
    "#);
}

#[rstest]
fn depth_to_space(graph: &OnnxGraph) {
    let node = find_node(graph, "depthtospace");
    insta::assert_snapshot!(format!("{node}"), @r#"
    DepthToSpace "depthtospace1"
      Inputs:
        depthtospace_input: F32[1, 8, 2, 2]
      Outputs:
        depthtospace1_out1: F32[1, 2, 4, 4]
      Config:
        DepthToSpaceConfig {
            mode: Dcr,
            block_size: 2,
        }
    "#);
}

#[rstest]
fn equal(graph: &OnnxGraph) {
    let node = find_node(graph, "equal");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Equal "equal1"
      Inputs:
        equal_a: F32[2, 3, 4]
        equal_b: F32[2, 3, 4]
      Outputs:
        equal1_out1: Bool[2, 3, 4]
    "#);
}

#[rstest]
fn flatten(graph: &OnnxGraph) {
    let node = find_node(graph, "flatten");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Flatten "flatten1"
      Inputs:
        flatten_input: F32[2, 3, 4]
      Outputs:
        flatten1_out1: F32[2, 12]
      Config:
        FlattenConfig {
            axis: 1,
        }
    "#);
}

#[rstest]
fn gather(graph: &OnnxGraph) {
    let node = find_node(graph, "gather");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Gather "gather1"
      Inputs:
        gather_input: F32[3, 4]
        constant6_out1: I64[2] [constant]
      Outputs:
        gather1_out1: F32[?, ?]
      Config:
        GatherConfig {
            axis: 0,
        }
    "#);
}

#[rstest]
fn gather_elements(graph: &OnnxGraph) {
    let node = find_node(graph, "gatherelements");
    insta::assert_snapshot!(format!("{node}"), @r#"
    GatherElements "gatherelements1"
      Inputs:
        gatherelements_input: F32[2, 3]
        constant7_out1: I64[2, 3] [constant]
      Outputs:
        gatherelements1_out1: F32[2, 3]
      Config:
        GatherElementsConfig {
            indices: Static(
                [
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                ],
            ),
            axis: 0,
        }
    "#);
}

#[rstest]
fn gather_nd(graph: &OnnxGraph) {
    let node = find_node(graph, "gathernd");
    insta::assert_snapshot!(format!("{node}"), @r#"
    GatherND "gathernd1"
      Inputs:
        gathernd_input: F32[2, 3, 4]
        constant8_out1: I64[2, 2] [constant]
      Outputs:
        gathernd1_out1: F32[?, ?]
      Config:
        GatherNDConfig {
            batch_dims: 0,
        }
    "#);
}

#[rstest]
fn gemm(graph: &OnnxGraph) {
    let node = find_node(graph, "gemm");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Gemm "gemm1"
      Inputs:
        gemm_a: F32[2, 3]
        constant9_out1: F32[3, 4] [constant]
        constant10_out1: F32[4] [constant]
      Outputs:
        gemm1_out1: F32[?, ?]
      Config:
        GemmConfig {
            alpha: 1.0,
            beta: 1.0,
            trans_a: 0,
            trans_b: 0,
        }
    "#);
}

#[rstest]
fn hardmax(graph: &OnnxGraph) {
    let node = find_node(graph, "hardmax");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Hardmax "hardmax1"
      Inputs:
        hardmax_input: F32[2, 3, 4]
      Outputs:
        hardmax1_out1: F32[2, 3, 4]
      Config:
        HardmaxConfig {
            axis: 1,
        }
    "#);
}

#[rstest]
fn if_op(graph: &OnnxGraph) {
    let node = find_node(graph, "if");
    insta::assert_snapshot!(format!("{node}"), @r#"
    If "if1"
      Inputs:
        if_condition: ScalarNative(Bool)
      Outputs:
        if1_out1: F32[2, 3]
      Config:
        IfConfig {
            then_branch: OnnxGraph {
                nodes: [
                    Constant(
                        ConstantNode {
                            name: "constant31",
                            inputs: [
                                Argument {
                                    name: "",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Static(
                                        0,
                                    ),
                                },
                            ],
                            outputs: [
                                Argument {
                                    name: "constant31_out1",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Constant,
                                },
                            ],
                        },
                    ),
                ],
                inputs: [],
                outputs: [
                    Argument {
                        name: "constant31_out1",
                        ty: Tensor(
                            TensorType {
                                dtype: F32,
                                rank: 2,
                                static_shape: Some(
                                    [
                                        Some(
                                            2,
                                        ),
                                        Some(
                                            3,
                                        ),
                                    ],
                                ),
                            },
                        ),
                        value_source: Constant,
                    },
                ],
                value_store: Some(
                    ValueStore {
                        tensor_store: TensorStore {
                            data: {
                                0: TensorDataRef {
                                    shape: [
                                        2,
                                        3,
                                    ],
                                    dtype: F32,
                                    source: Embedded(
                                        b"\0\0\x80?\0\0\x80?\0\0\x80?\0\0\x80?\0\0\x80?\0\0\x80?",
                                    ),
                                },
                            },
                            next_id: 1,
                        },
                        constant_map: {
                            "constant31_out1": 0,
                        },
                    },
                ),
            },
            else_branch: OnnxGraph {
                nodes: [
                    Constant(
                        ConstantNode {
                            name: "constant32",
                            inputs: [
                                Argument {
                                    name: "",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Static(
                                        0,
                                    ),
                                },
                            ],
                            outputs: [
                                Argument {
                                    name: "constant32_out1",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Constant,
                                },
                            ],
                        },
                    ),
                ],
                inputs: [],
                outputs: [
                    Argument {
                        name: "constant32_out1",
                        ty: Tensor(
                            TensorType {
                                dtype: F32,
                                rank: 2,
                                static_shape: Some(
                                    [
                                        Some(
                                            2,
                                        ),
                                        Some(
                                            3,
                                        ),
                                    ],
                                ),
                            },
                        ),
                        value_source: Constant,
                    },
                ],
                value_store: Some(
                    ValueStore {
                        tensor_store: TensorStore {
                            data: {
                                0: TensorDataRef {
                                    shape: [
                                        2,
                                        3,
                                    ],
                                    dtype: F32,
                                    source: Embedded(
                                        b"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                                    ),
                                },
                            },
                            next_id: 1,
                        },
                        constant_map: {
                            "constant32_out1": 0,
                        },
                    },
                ),
            },
            scope_ref_names: [],
        }
    "#);
}

#[rstest]
fn log_softmax(graph: &OnnxGraph) {
    let node = find_node(graph, "logsoftmax");
    insta::assert_snapshot!(format!("{node}"), @r#"
    LogSoftmax "logsoftmax1"
      Inputs:
        logsoftmax_input: F32[2, 3, 4]
      Outputs:
        logsoftmax1_out1: F32[2, 3, 4]
      Config:
        LogSoftmaxConfig {
            axis: 1,
        }
    "#);
}

#[rstest]
fn max_pool(graph: &OnnxGraph) {
    let node = find_node(graph, "maxpool2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    MaxPool2d "maxpool2d1"
      Inputs:
        maxpool_input: F32[1, 3, 8, 8]
      Outputs:
        maxpool2d1_out1: F32[1, 3, 8, 8]
      Config:
        MaxPool2dConfig {
            kernel_size: [
                2,
                2,
            ],
            strides: [
                2,
                2,
            ],
            padding: Valid,
            dilation: [
                1,
                1,
            ],
            ceil_mode: false,
            auto_pad: NotSet,
        }
    "#);
}

#[rstest]
fn one_hot(graph: &OnnxGraph) {
    let node = find_node(graph, "onehot");
    insta::assert_snapshot!(format!("{node}"), @r#"
    OneHot "onehot1"
      Inputs:
        onehot_indices: I64[3]
        _: ScalarNative(I64) [static(10)]
        _: F32[2] [static(11)]
      Outputs:
        onehot1_out1: F32[?, ?]
      Config:
        OneHotConfig {
            depth: Static(
                5,
            ),
            values: Static(
                [
                    0.0,
                    1.0,
                ],
            ),
            axis: -1,
        }
    "#);
}

#[rstest]
fn pad(graph: &OnnxGraph) {
    let node = find_node(graph, "pad");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Pad "pad1"
      Inputs:
        pad_input: F32[2, 3]
        _: I64[4] [static(12)]
        _: ScalarNative(F32) [static(13)]
      Outputs:
        pad1_out1: F32[2, 3]
      Config:
        PadConfig {
            pads: Static(
                [
                    (
                        0,
                        0,
                    ),
                    (
                        1,
                        1,
                    ),
                ],
            ),
            constant_value: Static(
                0.0,
            ),
            mode: Constant,
        }
    "#);
}

#[rstest]
fn range(graph: &OnnxGraph) {
    let node = find_node(graph, "range");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Range "range1"
      Inputs:
        _: ScalarNative(F32) [static(14)]
        _: ScalarNative(F32) [static(15)]
        _: ScalarNative(F32) [static(16)]
      Outputs:
        range1_out1: F32[?]
      Config:
        RangeConfig {
            start: Static(
                0,
            ),
            limit: Static(
                10,
            ),
            delta: Static(
                2,
            ),
        }
    "#);
}

#[rstest]
fn reduce_l1(graph: &OnnxGraph) {
    let node = find_node(graph, "reducel1");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceL1 "reducel11"
      Inputs:
        reducel1_input: F32[2, 3, 4]
      Outputs:
        reducel11_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_l2(graph: &OnnxGraph) {
    let node = find_node(graph, "reducel2");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceL2 "reducel21"
      Inputs:
        reducel2_input: F32[2, 3, 4]
      Outputs:
        reducel21_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_log_sum(graph: &OnnxGraph) {
    let node = find_node(graph, "reducelogsum");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceLogSum "reducelogsum1"
      Inputs:
        reducelogsum_input: F32[2, 3, 4]
      Outputs:
        reducelogsum1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_log_sum_exp(graph: &OnnxGraph) {
    let node = find_node(graph, "reducelogsumexp");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceLogSumExp "reducelogsumexp1"
      Inputs:
        reducelogsumexp_input: F32[2, 3, 4]
      Outputs:
        reducelogsumexp1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_max(graph: &OnnxGraph) {
    let node = find_node(graph, "reducemax");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceMax "reducemax1"
      Inputs:
        reducemax_input: F32[2, 3, 4]
      Outputs:
        reducemax1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_mean(graph: &OnnxGraph) {
    let node = find_node(graph, "reducemean");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceMean "reducemean1"
      Inputs:
        reducemean_input: F32[2, 3, 4]
      Outputs:
        reducemean1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_min(graph: &OnnxGraph) {
    let node = find_node(graph, "reducemin");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceMin "reducemin1"
      Inputs:
        reducemin_input: F32[2, 3, 4]
      Outputs:
        reducemin1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_prod(graph: &OnnxGraph) {
    let node = find_node(graph, "reduceprod");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceProd "reduceprod1"
      Inputs:
        reduceprod_input: F32[2, 3, 4]
      Outputs:
        reduceprod1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_sum(graph: &OnnxGraph) {
    let node = find_node(graph, "reducesum");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceSum "reducesum1"
      Inputs:
        reducesum_input: F32[2, 3, 4]
      Outputs:
        reducesum1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_sum_square(graph: &OnnxGraph) {
    let node = find_node(graph, "reducesumsquare");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceSumSquare "reducesumsquare1"
      Inputs:
        reducesumsquare_input: F32[2, 3, 4]
      Outputs:
        reducesumsquare1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn resize(graph: &OnnxGraph) {
    let node = find_node(graph, "resize");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Resize "resize1"
      Inputs:
        resize_input: F32[1, 1, 2, 2]
        _: F32[0] [static(17)]
        _: F32[0] [static(18)]
        _: I64[4] [static(19)]
      Outputs:
        resize1_out1: F32[1, 1, 2, 2]
      Config:
        ResizeConfig {
            mode: Nearest,
            scales: None,
            sizes: Some(
                Static(
                    [
                        4,
                        4,
                    ],
                ),
            ),
            coordinate_transformation_mode: "half_pixel",
            cubic_coeff_a: -0.75,
            nearest_mode: "round_prefer_floor",
            exclude_outside: 0,
            extrapolation_value: 0.0,
            antialias: 0,
        }
    "#);
}

#[rstest]
fn round(graph: &OnnxGraph) {
    let node = find_node(graph, "round");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Round "round1"
      Inputs:
        round_input: F32[2, 3, 4]
      Outputs:
        round1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn scatter_elements(graph: &OnnxGraph) {
    let node = find_node(graph, "scatterelements");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ScatterElements "scatterelements1"
      Inputs:
        scatterelements_input: F32[3, 3]
        constant21_out1: I64[1, 3] [constant]
        scatterelements_updates: F32[1, 3]
      Outputs:
        scatterelements1_out1: F32[3, 3]
      Config:
        ScatterElementsConfig {
            axis: 0,
            reduction: None,
        }
    "#);
}

#[rstest]
fn scatter_nd(graph: &OnnxGraph) {
    let node = find_node(graph, "scatternd");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ScatterND "scatternd1"
      Inputs:
        scatternd_input: F32[4, 4]
        constant22_out1: I64[2, 1] [constant]
        scatternd_updates: F32[2, 4]
      Outputs:
        scatternd1_out1: F32[4, 4]
      Config:
        ScatterNDConfig {
            reduction: None,
        }
    "#);
}

#[rstest]
fn slice(graph: &OnnxGraph) {
    let node = find_node(graph, "slice");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Slice "slice1"
      Inputs:
        slice_input: F32[4, 6]
        _: I64[2] [static(22)]
        _: I64[2] [static(23)]
        _: I64[2] [static(24)]
      Outputs:
        slice1_out1: F32[4, 6]
      Config:
        SliceConfig {
            starts: Static(
                [
                    0,
                    1,
                ],
            ),
            ends: Static(
                [
                    2,
                    4,
                ],
            ),
            axes: Some(
                Static(
                    [
                        0,
                        1,
                    ],
                ),
            ),
            steps: Some(
                Static(
                    [
                        1,
                        1,
                    ],
                ),
            ),
        }
    "#);
}

#[rstest]
fn softmax(graph: &OnnxGraph) {
    let node = find_node(graph, "softmax");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Softmax "softmax1"
      Inputs:
        softmax_input: F32[2, 3, 4]
      Outputs:
        softmax1_out1: F32[2, 3, 4]
      Config:
        SoftmaxConfig {
            axis: 1,
        }
    "#);
}

#[rstest]
fn split(graph: &OnnxGraph) {
    let node = find_node(graph, "split");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Split "split1"
      Inputs:
        split_input: F32[2, 6]
      Outputs:
        split1_out1: F32[2, 3]
        split1_out2: F32[2, 3]
      Config:
        SplitConfig {
            axis: 1,
            split_size: None,
            split_sizes: Some(
                Static(
                    [
                        3,
                        3,
                    ],
                ),
            ),
            num_outputs: None,
        }
    "#);
}

#[rstest]
fn squeeze(graph: &OnnxGraph) {
    let node = find_node(graph, "squeeze");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Squeeze "squeeze1"
      Inputs:
        squeeze_input: F32[1, 3, 1, 4]
      Outputs:
        squeeze1_out1: F32[3, 4]
      Config:
        SqueezeConfig {
            axes: Some(
                Static(
                    [
                        0,
                        2,
                    ],
                ),
            ),
        }
    "#);
}

#[rstest]
fn top_k(graph: &OnnxGraph) {
    let node = find_node(graph, "topk");
    insta::assert_snapshot!(format!("{node}"), @r#"
    TopK "topk1"
      Inputs:
        topk_input: F32[3, 4]
        _: I64[1] [static(25)]
      Outputs:
        topk1_out1: F32[?, ?]
        topk1_out2: I64[?, ?]
      Config:
        TopKConfig {
            axis: 1,
            k: Static(
                2,
            ),
        }
    "#);
}

#[rstest]
fn unsqueeze(graph: &OnnxGraph) {
    let node = find_node(graph, "unsqueeze");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Unsqueeze "unsqueeze1"
      Inputs:
        unsqueeze_input: F32[3, 4]
      Outputs:
        unsqueeze1_out1: F32[1, 3, 4, 1]
      Config:
        Static(
            [
                0,
                3,
            ],
        )
    "#);
}
