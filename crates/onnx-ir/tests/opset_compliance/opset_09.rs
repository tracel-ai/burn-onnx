//! Opset 9 compliance tests.
//!
//! Auto-generated by gen_rust_tests.py. Edit the generator, not this file.

use super::helpers::*;

#[test]
fn acosh() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "acosh");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Acosh "acosh1"
      Inputs:
        acosh_input: F32[2, 3, 4]
      Outputs:
        acosh1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn asinh() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "asinh");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Asinh "asinh1"
      Inputs:
        asinh_input: F32[2, 3, 4]
      Outputs:
        asinh1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn atanh() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "atanh");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Atanh "atanh1"
      Inputs:
        atanh_input: F32[2, 3, 4]
      Outputs:
        atanh1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn batch_normalization() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "batchnormalization");
    insta::assert_snapshot!(format!("{node}"), @r#"
    BatchNormalization "batchnormalization1"
      Inputs:
        batchnormalization_input: F32[1, 3, 4, 4]
        _: F32[3] [static(0)]
        _: F32[3] [static(1)]
        _: F32[3] [static(2)]
        _: F32[3] [static(3)]
      Outputs:
        batchnormalization1_out1: F32[1, 3, 4, 4]
      Config:
        Static(
            BatchNormStaticConfig {
                epsilon: 0.0,
                momentum: 0.0,
            },
        )
    "#);
}

#[test]
fn cast() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "cast");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Cast "cast1"
      Inputs:
        cast_input: F32[2, 3]
      Outputs:
        cast1_out1: I32[2, 3]
      Config:
        CastConfig {
            to: I32,
        }
    "#);
}

#[test]
fn constant() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "constant");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Constant "constant9"
      Inputs:
        _: F32[2, 3] [static(8)]
      Outputs:
        constant9_out1: F32[2, 3] [constant]
    "#);
}

#[test]
fn constant_of_shape() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "constantofshape");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ConstantOfShape "constantofshape1"
      Inputs:
        _: Shape(2) [static(4)]
      Outputs:
        constantofshape1_out1: F32[?, ?]
      Config:
        ConstantOfShapeConfig {
            shape: Static(
                [
                    2,
                    3,
                ],
            ),
            value: Some(
                TensorData {
                    bytes: Bytes {
                        data: [
                            0,
                            0,
                            128,
                            "...",
                        ],
                        len: 4,
                    },
                    shape: [
                        1,
                    ],
                    dtype: F32,
                },
            ),
        }
    "#);
}

#[test]
fn cosh() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "cosh");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Cosh "cosh1"
      Inputs:
        cosh_input: F32[2, 3, 4]
      Outputs:
        cosh1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn erf() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "erf");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Erf "erf1"
      Inputs:
        erf_input: F32[2, 3, 4]
      Outputs:
        erf1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn eye_like() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "eyelike");
    insta::assert_snapshot!(format!("{node}"), @r#"
    EyeLike "eyelike1"
      Inputs:
        eyelike_input: F32[3, 3]
      Outputs:
        eyelike1_out1: F32[3, 3]
      Config:
        EyeLikeConfig {
            dtype: None,
            k: 0,
        }
    "#);
}

#[test]
fn flatten() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "flatten");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Flatten "flatten1"
      Inputs:
        flatten_input: F32[2, 3, 4]
      Outputs:
        flatten1_out1: F32[2, 12]
      Config:
        FlattenConfig {
            axis: 1,
        }
    "#);
}

#[test]
fn greater() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "greater");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Greater "greater1"
      Inputs:
        greater_a: F32[2, 3, 4]
        greater_b: F32[2, 3, 4]
      Outputs:
        greater1_out1: Bool[?, ?, ?]
    "#);
}

#[test]
fn is_na_n() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "isnan");
    insta::assert_snapshot!(format!("{node}"), @r#"
    IsNaN "isnan1"
      Inputs:
        isnan_input: F32[2, 3]
      Outputs:
        isnan1_out1: Bool[?, ?]
    "#);
}

#[test]
fn less() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "less");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Less "less1"
      Inputs:
        less_a: F32[2, 3, 4]
        less_b: F32[2, 3, 4]
      Outputs:
        less1_out1: Bool[?, ?, ?]
    "#);
}

#[test]
fn mat_mul() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "matmul");
    insta::assert_snapshot!(format!("{node}"), @r#"
    MatMul "matmul1"
      Inputs:
        matmul_a: F32[2, 3]
        matmul_b: F32[3, 4]
      Outputs:
        matmul1_out1: F32[?, ?]
    "#);
}

#[test]
fn non_zero() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "nonzero");
    insta::assert_snapshot!(format!("{node}"), @r#"
    NonZero "nonzero1"
      Inputs:
        nonzero_input: F32[2, 3]
      Outputs:
        nonzero1_out1: I64[2, ?]
    "#);
}

#[test]
fn one_hot() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "onehot");
    insta::assert_snapshot!(format!("{node}"), @r#"
    OneHot "onehot1"
      Inputs:
        onehot_indices: I64[3]
        _: Scalar(I64) [static(5)]
        _: F32[2] [static(6)]
      Outputs:
        onehot1_out1: F32[?, ?]
      Config:
        OneHotConfig {
            depth: Static(
                5,
            ),
            values: Static(
                [
                    0.0,
                    1.0,
                ],
            ),
            axis: -1,
        }
    "#);
}

#[test]
fn p_relu() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "prelu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    PRelu "prelu1"
      Inputs:
        prelu_input: F32[2, 3, 4]
        _: F32[1] [static(7)]
      Outputs:
        prelu1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn sign() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "sign");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sign "sign1"
      Inputs:
        sign_input: F32[2, 3, 4]
      Outputs:
        sign1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn sinh() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "sinh");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sinh "sinh1"
      Inputs:
        sinh_input: F32[2, 3, 4]
      Outputs:
        sinh1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn where_op() {
    let graph = load_model("opset_09.onnx");
    let node = find_node(&graph, "where");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Where "where1"
      Inputs:
        where_condition: Bool[2, 3]
        where_x: F32[2, 3]
        where_y: F32[2, 3]
      Outputs:
        where1_out1: F32[2, 3]
    "#);
}

/// Ops that require min_opset > 9: Gemm
#[test]
fn unsupported_ops_fail() {
    let result = load_model_result("opset_09_unsupported.onnx");
    assert!(result.is_err(), "expected parse failure for unsupported ops at opset 9");
}

