//! Opset 10 compliance tests.
//!
//! Auto-generated by gen_rust_tests.py. Edit the generator, not this file.

use super::helpers::*;
use rstest::*;

#[fixture]
#[once]
fn graph() -> OnnxGraph {
    load_model("opset_10.onnx")
}

#[rstest]
fn average_pool(graph: &OnnxGraph) {
    let node = find_node(graph, "averagepool2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    AveragePool2d "averagepool2d1"
      Inputs:
        averagepool_input: F32[1, 3, 8, 8]
      Outputs:
        averagepool2d1_out1: F32[?, ?, ?, ?]
      Config:
        AvgPool2dConfig {
            kernel_size: [
                2,
                2,
            ],
            strides: [
                2,
                2,
            ],
            padding: Valid,
            count_include_pad: false,
            dilation: [
                1,
                1,
            ],
            ceil_mode: false,
            auto_pad: NotSet,
        }
    "#);
}

/// Dropout is eliminated during post-processing (no-op).
/// Verify the model parses without error.
#[test]
fn dropout() {
    let _graph = load_model("opset_10.onnx");
}

#[rstest]
fn is_inf(graph: &OnnxGraph) {
    let node = find_node(graph, "isinf");
    insta::assert_snapshot!(format!("{node}"), @r#"
    IsInf "isinf1"
      Inputs:
        isinf_input: F32[2, 3]
      Outputs:
        isinf1_out1: Bool[?, ?]
      Config:
        IsInfConfig {
            detect_negative: true,
            detect_positive: true,
        }
    "#);
}

#[rstest]
fn mat_mul_integer(graph: &OnnxGraph) {
    let node = find_node(graph, "matmulinteger");
    insta::assert_snapshot!(format!("{node}"), @r#"
    MatMulInteger "matmulinteger1"
      Inputs:
        matmulinteger_a: U8[2, 3]
        matmulinteger_b: U8[3, 4]
      Outputs:
        matmulinteger1_out1: I32[?, ?]
    "#);
}

#[rstest]
fn max_pool(graph: &OnnxGraph) {
    let node = find_node(graph, "maxpool2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    MaxPool2d "maxpool2d1"
      Inputs:
        maxpool_input: F32[1, 3, 8, 8]
      Outputs:
        maxpool2d1_out1: F32[1, 3, 8, 8]
      Config:
        MaxPool2dConfig {
            kernel_size: [
                2,
                2,
            ],
            strides: [
                2,
                2,
            ],
            padding: Valid,
            dilation: [
                1,
                1,
            ],
            ceil_mode: false,
            auto_pad: NotSet,
        }
    "#);
}

#[rstest]
fn mod_op(graph: &OnnxGraph) {
    let node = find_node(graph, "mod");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Mod "mod1"
      Inputs:
        mod_a: F32[2, 3, 4]
        mod_b: F32[2, 3, 4]
      Outputs:
        mod1_out1: F32[2, 3, 4]
      Config:
        ModConfig {
            fmod: false,
        }
    "#);
}

#[rstest]
fn resize(graph: &OnnxGraph) {
    let node = find_node(graph, "resize");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Resize "resize1"
      Inputs:
        resize_input: F32[1, 1, 2, 2]
        _: F32[4] [static(0)]
      Outputs:
        resize1_out1: F32[1, 1, 2, 2]
      Config:
        ResizeConfig {
            mode: Nearest,
            scales: Some(
                Static(
                    [
                        2.0,
                        2.0,
                    ],
                ),
            ),
            sizes: None,
            coordinate_transformation_mode: "asymmetric",
            cubic_coeff_a: -0.75,
            nearest_mode: "round_prefer_floor",
            exclude_outside: 0,
            extrapolation_value: 0.0,
            antialias: 0,
        }
    "#);
}

#[rstest]
fn slice(graph: &OnnxGraph) {
    let node = find_node(graph, "slice");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Slice "slice1"
      Inputs:
        slice_input: F32[4, 6]
        _: I64[2] [static(1)]
        _: I64[2] [static(2)]
        _: I64[2] [static(3)]
      Outputs:
        slice1_out1: F32[4, 6]
      Config:
        SliceConfig {
            starts: Static(
                [
                    0,
                    1,
                ],
            ),
            ends: Static(
                [
                    2,
                    4,
                ],
            ),
            axes: Some(
                Static(
                    [
                        0,
                        1,
                    ],
                ),
            ),
            steps: Some(
                Static(
                    [
                        1,
                        1,
                    ],
                ),
            ),
        }
    "#);
}

#[rstest]
fn thresholded_relu(graph: &OnnxGraph) {
    let node = find_node(graph, "thresholdedrelu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ThresholdedRelu "thresholdedrelu1"
      Inputs:
        thresholdedrelu_input: F32[2, 3, 4]
      Outputs:
        thresholdedrelu1_out1: F32[2, 3, 4]
      Config:
        ThresholdedReluConfig {
            alpha: 1.0,
        }
    "#);
}

#[rstest]
fn top_k(graph: &OnnxGraph) {
    let node = find_node(graph, "topk");
    insta::assert_snapshot!(format!("{node}"), @r#"
    TopK "topk1"
      Inputs:
        topk_input: F32[3, 4]
        _: I64[1] [static(4)]
      Outputs:
        topk1_out1: F32[?, ?]
        topk1_out2: I64[?, ?]
      Config:
        TopKConfig {
            axis: 1,
            k: Static(
                2,
            ),
        }
    "#);
}
