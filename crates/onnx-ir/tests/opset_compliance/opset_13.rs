//! Opset 13 compliance tests.
//!
//! Auto-generated by gen_rust_tests.py. Edit the generator, not this file.

use super::helpers::*;
use rstest::*;

#[fixture]
#[once]
fn graph() -> OnnxGraph {
    load_model("opset_13.onnx")
}

#[rstest]
fn abs(graph: &OnnxGraph) {
    let node = find_node(graph, "abs");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Abs "abs1"
      Inputs:
        abs_input: F32[2, 3, 4]
      Outputs:
        abs1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn add(graph: &OnnxGraph) {
    let node = find_node(graph, "add");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Add "add1"
      Inputs:
        add_a: F32[2, 3, 4]
        add_b: F32[2, 3, 4]
      Outputs:
        add1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn arg_max(graph: &OnnxGraph) {
    let node = find_node(graph, "argmax");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ArgMax "argmax1"
      Inputs:
        argmax_input: F32[2, 3, 4]
      Outputs:
        argmax1_out1: I64[?, ?, ?]
      Config:
        ArgMaxConfig {
            axis: 1,
            keepdims: true,
        }
    "#);
}

#[rstest]
fn arg_min(graph: &OnnxGraph) {
    let node = find_node(graph, "argmin");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ArgMin "argmin1"
      Inputs:
        argmin_input: F32[2, 3, 4]
      Outputs:
        argmin1_out1: I64[?, ?, ?]
      Config:
        ArgMinConfig {
            axis: 1,
            keepdims: true,
        }
    "#);
}

#[rstest]
fn cast(graph: &OnnxGraph) {
    let node = find_node(graph, "cast");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Cast "cast1"
      Inputs:
        cast_input: F32[2, 3]
      Outputs:
        cast1_out1: I32[2, 3]
      Config:
        CastConfig {
            to: I32,
        }
    "#);
}

#[rstest]
fn ceil(graph: &OnnxGraph) {
    let node = find_node(graph, "ceil");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Ceil "ceil1"
      Inputs:
        ceil_input: F32[2, 3, 4]
      Outputs:
        ceil1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn clip(graph: &OnnxGraph) {
    let node = find_node(graph, "clip");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Clip "clip1"
      Inputs:
        clip_input: F32[2, 3, 4]
        _: Scalar(F32) [static(0)]
        _: Scalar(F32) [static(1)]
      Outputs:
        clip1_out1: F32[2, 3, 4]
      Config:
        ClipConfig {
            min: Some(
                Static(
                    0.0,
                ),
            ),
            max: Some(
                Static(
                    6.0,
                ),
            ),
        }
    "#);
}

#[rstest]
fn concat(graph: &OnnxGraph) {
    let node = find_node(graph, "concat");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Concat "concat1"
      Inputs:
        concat_a: F32[2, 3]
        concat_b: F32[2, 3]
      Outputs:
        concat1_out1: F32[?, ?]
      Config:
        ConcatConfig {
            axis: 0,
        }
    "#);
}

#[rstest]
fn constant(graph: &OnnxGraph) {
    let node = find_node(graph, "constant");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Constant "constant6"
      Inputs:
        _: I64[2] [static(5)]
      Outputs:
        constant6_out1: I64[2] [constant]
    "#);
}

#[rstest]
fn depth_to_space(graph: &OnnxGraph) {
    let node = find_node(graph, "depthtospace");
    insta::assert_snapshot!(format!("{node}"), @r#"
    DepthToSpace "depthtospace1"
      Inputs:
        depthtospace_input: F32[1, 8, 2, 2]
      Outputs:
        depthtospace1_out1: F32[1, 2, 4, 4]
      Config:
        DepthToSpaceConfig {
            mode: Dcr,
            block_size: 2,
        }
    "#);
}

#[rstest]
fn div(graph: &OnnxGraph) {
    let node = find_node(graph, "div");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Div "div1"
      Inputs:
        div_a: F32[2, 3, 4]
        div_b: F32[2, 3, 4]
      Outputs:
        div1_out1: F32[2, 3, 4]
    "#);
}

/// Dropout is eliminated during post-processing (no-op).
/// Verify the model parses without error.
#[test]
fn dropout() {
    let _graph = load_model("opset_13.onnx");
}

#[rstest]
fn equal(graph: &OnnxGraph) {
    let node = find_node(graph, "equal");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Equal "equal1"
      Inputs:
        equal_a: F32[2, 3, 4]
        equal_b: F32[2, 3, 4]
      Outputs:
        equal1_out1: Bool[?, ?, ?]
    "#);
}

#[rstest]
fn erf(graph: &OnnxGraph) {
    let node = find_node(graph, "erf");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Erf "erf1"
      Inputs:
        erf_input: F32[2, 3, 4]
      Outputs:
        erf1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn exp(graph: &OnnxGraph) {
    let node = find_node(graph, "exp");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Exp "exp1"
      Inputs:
        exp_input: F32[2, 3, 4]
      Outputs:
        exp1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn expand(graph: &OnnxGraph) {
    let node = find_node(graph, "expand");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Expand "expand1"
      Inputs:
        expand_input: F32[1, 3]
        _: I64[2] [static(4)]
      Outputs:
        expand1_out1: F32[2, 3]
      Config:
        Static(
            [
                2,
                3,
            ],
        )
    "#);
}

#[rstest]
fn flatten(graph: &OnnxGraph) {
    let node = find_node(graph, "flatten");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Flatten "flatten1"
      Inputs:
        flatten_input: F32[2, 3, 4]
      Outputs:
        flatten1_out1: F32[2, 12]
      Config:
        FlattenConfig {
            axis: 1,
        }
    "#);
}

#[rstest]
fn floor(graph: &OnnxGraph) {
    let node = find_node(graph, "floor");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Floor "floor1"
      Inputs:
        floor_input: F32[2, 3, 4]
      Outputs:
        floor1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn gather(graph: &OnnxGraph) {
    let node = find_node(graph, "gather");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Gather "gather1"
      Inputs:
        gather_input: F32[3, 4]
        constant6_out1: I64[2] [constant]
      Outputs:
        gather1_out1: F32[?, ?]
      Config:
        GatherConfig {
            axis: 0,
        }
    "#);
}

#[rstest]
fn gather_elements(graph: &OnnxGraph) {
    let node = find_node(graph, "gatherelements");
    insta::assert_snapshot!(format!("{node}"), @r#"
    GatherElements "gatherelements1"
      Inputs:
        gatherelements_input: F32[2, 3]
        constant7_out1: I64[2, 3] [constant]
      Outputs:
        gatherelements1_out1: F32[2, 3]
      Config:
        GatherElementsConfig {
            indices: Static(
                [
                    0,
                    1,
                    0,
                    1,
                    0,
                    1,
                ],
            ),
            axis: 0,
        }
    "#);
}

#[rstest]
fn gather_nd(graph: &OnnxGraph) {
    let node = find_node(graph, "gathernd");
    insta::assert_snapshot!(format!("{node}"), @r#"
    GatherND "gathernd1"
      Inputs:
        gathernd_input: F32[2, 3, 4]
        constant8_out1: I64[2, 2] [constant]
      Outputs:
        gathernd1_out1: F32[?, ?]
      Config:
        GatherNDConfig {
            batch_dims: 0,
        }
    "#);
}

#[rstest]
fn gemm(graph: &OnnxGraph) {
    let node = find_node(graph, "gemm");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Gemm "gemm1"
      Inputs:
        gemm_a: F32[2, 3]
        constant9_out1: F32[3, 4] [constant]
        constant10_out1: F32[4] [constant]
      Outputs:
        gemm1_out1: F32[?, ?]
      Config:
        GemmConfig {
            alpha: 1.0,
            beta: 1.0,
            trans_a: 0,
            trans_b: 0,
        }
    "#);
}

#[rstest]
fn greater(graph: &OnnxGraph) {
    let node = find_node(graph, "greater");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Greater "greater1"
      Inputs:
        greater_a: F32[2, 3, 4]
        greater_b: F32[2, 3, 4]
      Outputs:
        greater1_out1: Bool[?, ?, ?]
    "#);
}

#[rstest]
fn hardmax(graph: &OnnxGraph) {
    let node = find_node(graph, "hardmax");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Hardmax "hardmax1"
      Inputs:
        hardmax_input: F32[2, 3, 4]
      Outputs:
        hardmax1_out1: F32[2, 3, 4]
      Config:
        HardmaxConfig {
            axis: 2,
        }
    "#);
}

/// Identity is eliminated during post-processing (no-op).
/// Verify the model parses without error.
#[test]
fn identity() {
    let _graph = load_model("opset_13.onnx");
}

#[rstest]
fn if_op(graph: &OnnxGraph) {
    let node = find_node(graph, "if");
    insta::assert_snapshot!(format!("{node}"), @r#"
    If "if1"
      Inputs:
        if_condition: Scalar(Bool)
      Outputs:
        if1_out1: F32[2, 3]
      Config:
        IfConfig {
            then_branch: OnnxGraph {
                nodes: [
                    Constant(
                        ConstantNode {
                            name: "constant31",
                            inputs: [
                                Argument {
                                    name: "",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Static(
                                        0,
                                    ),
                                },
                            ],
                            outputs: [
                                Argument {
                                    name: "constant31_out1",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Constant,
                                },
                            ],
                        },
                    ),
                ],
                inputs: [],
                outputs: [
                    Argument {
                        name: "constant31_out1",
                        ty: Tensor(
                            TensorType {
                                dtype: F32,
                                rank: 2,
                                static_shape: Some(
                                    [
                                        Some(
                                            2,
                                        ),
                                        Some(
                                            3,
                                        ),
                                    ],
                                ),
                            },
                        ),
                        value_source: Constant,
                    },
                ],
                value_store: Some(
                    ValueStore {
                        tensor_store: TensorStore {
                            data: {
                                0: TensorDataRef {
                                    shape: [
                                        2,
                                        3,
                                    ],
                                    dtype: F32,
                                    source: Embedded(
                                        b"\0\0\x80?\0\0\x80?\0\0\x80?\0\0\x80?\0\0\x80?\0\0\x80?",
                                    ),
                                },
                            },
                            next_id: 1,
                        },
                        constant_map: {
                            "constant31_out1": 0,
                        },
                    },
                ),
            },
            else_branch: OnnxGraph {
                nodes: [
                    Constant(
                        ConstantNode {
                            name: "constant32",
                            inputs: [
                                Argument {
                                    name: "",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Static(
                                        0,
                                    ),
                                },
                            ],
                            outputs: [
                                Argument {
                                    name: "constant32_out1",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Constant,
                                },
                            ],
                        },
                    ),
                ],
                inputs: [],
                outputs: [
                    Argument {
                        name: "constant32_out1",
                        ty: Tensor(
                            TensorType {
                                dtype: F32,
                                rank: 2,
                                static_shape: Some(
                                    [
                                        Some(
                                            2,
                                        ),
                                        Some(
                                            3,
                                        ),
                                    ],
                                ),
                            },
                        ),
                        value_source: Constant,
                    },
                ],
                value_store: Some(
                    ValueStore {
                        tensor_store: TensorStore {
                            data: {
                                0: TensorDataRef {
                                    shape: [
                                        2,
                                        3,
                                    ],
                                    dtype: F32,
                                    source: Embedded(
                                        b"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                                    ),
                                },
                            },
                            next_id: 1,
                        },
                        constant_map: {
                            "constant32_out1": 0,
                        },
                    },
                ),
            },
            scope_ref_names: [],
        }
    "#);
}

#[rstest]
fn is_na_n(graph: &OnnxGraph) {
    let node = find_node(graph, "isnan");
    insta::assert_snapshot!(format!("{node}"), @r#"
    IsNaN "isnan1"
      Inputs:
        isnan_input: F32[2, 3]
      Outputs:
        isnan1_out1: Bool[?, ?]
    "#);
}

#[rstest]
fn less(graph: &OnnxGraph) {
    let node = find_node(graph, "less");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Less "less1"
      Inputs:
        less_a: F32[2, 3, 4]
        less_b: F32[2, 3, 4]
      Outputs:
        less1_out1: Bool[?, ?, ?]
    "#);
}

#[rstest]
fn log(graph: &OnnxGraph) {
    let node = find_node(graph, "log");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Log "log1"
      Inputs:
        log_input: F32[2, 3, 4]
      Outputs:
        log1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn log_softmax(graph: &OnnxGraph) {
    let node = find_node(graph, "logsoftmax");
    insta::assert_snapshot!(format!("{node}"), @r#"
    LogSoftmax "logsoftmax1"
      Inputs:
        logsoftmax_input: F32[2, 3, 4]
      Outputs:
        logsoftmax1_out1: F32[2, 3, 4]
      Config:
        LogSoftmaxConfig {
            axis: 2,
        }
    "#);
}

#[rstest]
fn mat_mul(graph: &OnnxGraph) {
    let node = find_node(graph, "matmul");
    insta::assert_snapshot!(format!("{node}"), @r#"
    MatMul "matmul1"
      Inputs:
        matmul_a: F32[2, 3]
        matmul_b: F32[3, 4]
      Outputs:
        matmul1_out1: F32[?, ?]
    "#);
}

#[rstest]
fn max(graph: &OnnxGraph) {
    let node = find_node(graph, "max");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Max "max1"
      Inputs:
        max_a: F32[2, 3, 4]
        max_b: F32[2, 3, 4]
      Outputs:
        max1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn mean(graph: &OnnxGraph) {
    let node = find_node(graph, "mean");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Mean "mean1"
      Inputs:
        mean_a: F32[2, 3, 4]
        mean_b: F32[2, 3, 4]
      Outputs:
        mean1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn min(graph: &OnnxGraph) {
    let node = find_node(graph, "min");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Min "min1"
      Inputs:
        min_a: F32[2, 3, 4]
        min_b: F32[2, 3, 4]
      Outputs:
        min1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn mod_op(graph: &OnnxGraph) {
    let node = find_node(graph, "mod");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Mod "mod1"
      Inputs:
        mod_a: F32[2, 3, 4]
        mod_b: F32[2, 3, 4]
      Outputs:
        mod1_out1: F32[2, 3, 4]
      Config:
        ModConfig {
            fmod: false,
        }
    "#);
}

#[rstest]
fn mul(graph: &OnnxGraph) {
    let node = find_node(graph, "mul");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Mul "mul1"
      Inputs:
        mul_a: F32[2, 3, 4]
        mul_b: F32[2, 3, 4]
      Outputs:
        mul1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn neg(graph: &OnnxGraph) {
    let node = find_node(graph, "neg");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Neg "neg1"
      Inputs:
        neg_input: F32[2, 3, 4]
      Outputs:
        neg1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn non_zero(graph: &OnnxGraph) {
    let node = find_node(graph, "nonzero");
    insta::assert_snapshot!(format!("{node}"), @r#"
    NonZero "nonzero1"
      Inputs:
        nonzero_input: F32[2, 3]
      Outputs:
        nonzero1_out1: I64[2, ?]
    "#);
}

#[rstest]
fn pad(graph: &OnnxGraph) {
    let node = find_node(graph, "pad");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Pad "pad1"
      Inputs:
        pad_input: F32[2, 3]
        _: I64[4] [static(10)]
        _: Scalar(F32) [static(11)]
      Outputs:
        pad1_out1: F32[2, 3]
      Config:
        PadConfig {
            pads: Static(
                [
                    (
                        0,
                        0,
                    ),
                    (
                        1,
                        1,
                    ),
                ],
            ),
            constant_value: Static(
                0.0,
            ),
            mode: Constant,
        }
    "#);
}

#[rstest]
fn pow(graph: &OnnxGraph) {
    let node = find_node(graph, "pow");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Pow "pow1"
      Inputs:
        pow_a: F32[2, 3, 4]
        pow_b: F32[2, 3, 4]
      Outputs:
        pow1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn reciprocal(graph: &OnnxGraph) {
    let node = find_node(graph, "reciprocal");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Reciprocal "reciprocal1"
      Inputs:
        reciprocal_input: F32[2, 3, 4]
      Outputs:
        reciprocal1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn reduce_l1(graph: &OnnxGraph) {
    let node = find_node(graph, "reducel1");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceL1 "reducel11"
      Inputs:
        reducel1_input: F32[2, 3, 4]
      Outputs:
        reducel11_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_l2(graph: &OnnxGraph) {
    let node = find_node(graph, "reducel2");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceL2 "reducel21"
      Inputs:
        reducel2_input: F32[2, 3, 4]
      Outputs:
        reducel21_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_log_sum(graph: &OnnxGraph) {
    let node = find_node(graph, "reducelogsum");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceLogSum "reducelogsum1"
      Inputs:
        reducelogsum_input: F32[2, 3, 4]
      Outputs:
        reducelogsum1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_log_sum_exp(graph: &OnnxGraph) {
    let node = find_node(graph, "reducelogsumexp");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceLogSumExp "reducelogsumexp1"
      Inputs:
        reducelogsumexp_input: F32[2, 3, 4]
      Outputs:
        reducelogsumexp1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_max(graph: &OnnxGraph) {
    let node = find_node(graph, "reducemax");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceMax "reducemax1"
      Inputs:
        reducemax_input: F32[2, 3, 4]
      Outputs:
        reducemax1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_mean(graph: &OnnxGraph) {
    let node = find_node(graph, "reducemean");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceMean "reducemean1"
      Inputs:
        reducemean_input: F32[2, 3, 4]
      Outputs:
        reducemean1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_min(graph: &OnnxGraph) {
    let node = find_node(graph, "reducemin");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceMin "reducemin1"
      Inputs:
        reducemin_input: F32[2, 3, 4]
      Outputs:
        reducemin1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_prod(graph: &OnnxGraph) {
    let node = find_node(graph, "reduceprod");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceProd "reduceprod1"
      Inputs:
        reduceprod_input: F32[2, 3, 4]
      Outputs:
        reduceprod1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_sum(graph: &OnnxGraph) {
    let node = find_node(graph, "reducesum");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceSum "reducesum1"
      Inputs:
        reducesum_input: F32[2, 3, 4]
        _: I64[1] [static(12)]
      Outputs:
        reducesum1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_sum_square(graph: &OnnxGraph) {
    let node = find_node(graph, "reducesumsquare");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceSumSquare "reducesumsquare1"
      Inputs:
        reducesumsquare_input: F32[2, 3, 4]
      Outputs:
        reducesumsquare1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn relu(graph: &OnnxGraph) {
    let node = find_node(graph, "relu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Relu "relu1"
      Inputs:
        relu_input: F32[2, 3, 4]
      Outputs:
        relu1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn reshape(graph: &OnnxGraph) {
    let node = find_node(graph, "reshape");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Reshape "reshape1"
      Inputs:
        reshape_input: F32[2, 3, 4]
        _: I64[2] [static(13)]
      Outputs:
        reshape1_out1: F32[6, 4]
      Config:
        ReshapeConfig {
            shape: Static(
                [
                    6,
                    4,
                ],
            ),
        }
    "#);
}

#[rstest]
fn resize(graph: &OnnxGraph) {
    let node = find_node(graph, "resize");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Resize "resize1"
      Inputs:
        resize_input: F32[1, 1, 2, 2]
        _: F32[0] [static(14)]
        _: F32[0] [static(15)]
        _: I64[4] [static(16)]
      Outputs:
        resize1_out1: F32[1, 1, 2, 2]
      Config:
        ResizeConfig {
            mode: Nearest,
            scales: None,
            sizes: Some(
                Static(
                    [
                        4,
                        4,
                    ],
                ),
            ),
            coordinate_transformation_mode: "half_pixel",
            cubic_coeff_a: -0.75,
            nearest_mode: "round_prefer_floor",
            exclude_outside: 0,
            extrapolation_value: 0.0,
            antialias: 0,
        }
    "#);
}

#[rstest]
fn scatter_elements(graph: &OnnxGraph) {
    let node = find_node(graph, "scatterelements");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ScatterElements "scatterelements1"
      Inputs:
        scatterelements_input: F32[3, 3]
        constant18_out1: I64[1, 3] [constant]
        scatterelements_updates: F32[1, 3]
      Outputs:
        scatterelements1_out1: F32[3, 3]
      Config:
        ScatterElementsConfig {
            axis: 0,
            reduction: None,
        }
    "#);
}

#[rstest]
fn scatter_nd(graph: &OnnxGraph) {
    let node = find_node(graph, "scatternd");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ScatterND "scatternd1"
      Inputs:
        scatternd_input: F32[4, 4]
        constant19_out1: I64[2, 1] [constant]
        scatternd_updates: F32[2, 4]
      Outputs:
        scatternd1_out1: F32[4, 4]
      Config:
        ScatterNDConfig {
            reduction: None,
        }
    "#);
}

#[rstest]
fn shape(graph: &OnnxGraph) {
    let node = find_node(graph, "shape");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Shape "shape1"
      Inputs:
        shape_input: F32[2, 3, 4]
      Outputs:
        shape1_out1: Shape(3)
      Config:
        ShapeConfig {
            start: 0,
            end: 3,
        }
    "#);
}

#[rstest]
fn sigmoid(graph: &OnnxGraph) {
    let node = find_node(graph, "sigmoid");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sigmoid "sigmoid1"
      Inputs:
        sigmoid_input: F32[2, 3, 4]
      Outputs:
        sigmoid1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn sign(graph: &OnnxGraph) {
    let node = find_node(graph, "sign");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sign "sign1"
      Inputs:
        sign_input: F32[2, 3, 4]
      Outputs:
        sign1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn size(graph: &OnnxGraph) {
    let node = find_node(graph, "size");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Size "size1"
      Inputs:
        size_input: F32[2, 3, 4]
      Outputs:
        size1_out1: Scalar(I64)
    "#);
}

#[rstest]
fn slice(graph: &OnnxGraph) {
    let node = find_node(graph, "slice");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Slice "slice1"
      Inputs:
        slice_input: F32[4, 6]
        _: I64[2] [static(19)]
        _: I64[2] [static(20)]
        _: I64[2] [static(21)]
      Outputs:
        slice1_out1: F32[4, 6]
      Config:
        SliceConfig {
            starts: Static(
                [
                    0,
                    1,
                ],
            ),
            ends: Static(
                [
                    2,
                    4,
                ],
            ),
            axes: Some(
                Static(
                    [
                        0,
                        1,
                    ],
                ),
            ),
            steps: Some(
                Static(
                    [
                        1,
                        1,
                    ],
                ),
            ),
        }
    "#);
}

#[rstest]
fn softmax(graph: &OnnxGraph) {
    let node = find_node(graph, "softmax");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Softmax "softmax1"
      Inputs:
        softmax_input: F32[2, 3, 4]
      Outputs:
        softmax1_out1: F32[2, 3, 4]
      Config:
        SoftmaxConfig {
            axis: 2,
        }
    "#);
}

#[rstest]
fn space_to_depth(graph: &OnnxGraph) {
    let node = find_node(graph, "spacetodepth");
    insta::assert_snapshot!(format!("{node}"), @r#"
    SpaceToDepth "spacetodepth1"
      Inputs:
        spacetodepth_input: F32[1, 2, 4, 4]
      Outputs:
        spacetodepth1_out1: F32[1, 8, 2, 2]
      Config:
        SpaceToDepthConfig {
            block_size: 2,
        }
    "#);
}

#[rstest]
fn split(graph: &OnnxGraph) {
    let node = find_node(graph, "split");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Split "split1"
      Inputs:
        split_input: F32[2, 6]
        _: I64[2] [static(22)]
      Outputs:
        split1_out1: F32[2, 3]
        split1_out2: F32[2, 3]
      Config:
        SplitConfig {
            axis: 1,
            split_size: None,
            split_sizes: Some(
                Static(
                    [
                        3,
                        3,
                    ],
                ),
            ),
            num_outputs: None,
        }
    "#);
}

#[rstest]
fn sqrt(graph: &OnnxGraph) {
    let node = find_node(graph, "sqrt");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sqrt "sqrt1"
      Inputs:
        sqrt_input: F32[2, 3, 4]
      Outputs:
        sqrt1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn squeeze(graph: &OnnxGraph) {
    let node = find_node(graph, "squeeze");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Squeeze "squeeze1"
      Inputs:
        squeeze_input: F32[1, 3, 1, 4]
        _: I64[2] [static(23)]
      Outputs:
        squeeze1_out1: F32[3, 4]
      Config:
        SqueezeConfig {
            axes: Some(
                Static(
                    [
                        0,
                        2,
                    ],
                ),
            ),
        }
    "#);
}

#[rstest]
fn sub(graph: &OnnxGraph) {
    let node = find_node(graph, "sub");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sub "sub1"
      Inputs:
        sub_a: F32[2, 3, 4]
        sub_b: F32[2, 3, 4]
      Outputs:
        sub1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn sum(graph: &OnnxGraph) {
    let node = find_node(graph, "sum");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sum "sum1"
      Inputs:
        sum_a: F32[2, 3, 4]
        sum_b: F32[2, 3, 4]
      Outputs:
        sum1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn tanh(graph: &OnnxGraph) {
    let node = find_node(graph, "tanh");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Tanh "tanh1"
      Inputs:
        tanh_input: F32[2, 3, 4]
      Outputs:
        tanh1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn tile(graph: &OnnxGraph) {
    let node = find_node(graph, "tile");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Tile "tile1"
      Inputs:
        tile_input: F32[2, 3]
        _: I64[2] [static(24)]
      Outputs:
        tile1_out1: F32[2, 3]
      Config:
        TileConfig {
            repeats: Static(
                [
                    2,
                    3,
                ],
            ),
        }
    "#);
}

#[rstest]
fn transpose(graph: &OnnxGraph) {
    let node = find_node(graph, "transpose");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Transpose "transpose1"
      Inputs:
        transpose_input: F32[2, 3, 4]
      Outputs:
        transpose1_out1: F32[4, 3, 2]
      Config:
        TransposeConfig {
            perm: [
                2,
                1,
                0,
            ],
        }
    "#);
}

#[rstest]
fn unsqueeze(graph: &OnnxGraph) {
    let node = find_node(graph, "unsqueeze");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Unsqueeze "unsqueeze1"
      Inputs:
        unsqueeze_input: F32[3, 4]
        _: I64[2] [static(25)]
      Outputs:
        unsqueeze1_out1: F32[1, 3, 4, 1]
      Config:
        Static(
            [
                0,
                3,
            ],
        )
    "#);
}
