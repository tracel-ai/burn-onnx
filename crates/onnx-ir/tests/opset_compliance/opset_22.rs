//! Opset 22 compliance tests.
//!
//! Auto-generated by gen_rust_tests.py. Edit the generator, not this file.

use super::helpers::*;
use rstest::*;

#[fixture]
#[once]
fn graph() -> OnnxGraph {
    load_model("opset_22.onnx")
}

#[rstest]
fn acos(graph: &OnnxGraph) {
    let node = find_node(graph, "acos");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Acos "acos1"
      Inputs:
        acos_input: F32[2, 3, 4]
      Outputs:
        acos1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn acosh(graph: &OnnxGraph) {
    let node = find_node(graph, "acosh");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Acosh "acosh1"
      Inputs:
        acosh_input: F32[2, 3, 4]
      Outputs:
        acosh1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn asin(graph: &OnnxGraph) {
    let node = find_node(graph, "asin");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Asin "asin1"
      Inputs:
        asin_input: F32[2, 3, 4]
      Outputs:
        asin1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn asinh(graph: &OnnxGraph) {
    let node = find_node(graph, "asinh");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Asinh "asinh1"
      Inputs:
        asinh_input: F32[2, 3, 4]
      Outputs:
        asinh1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn atan(graph: &OnnxGraph) {
    let node = find_node(graph, "atan");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Atan "atan1"
      Inputs:
        atan_input: F32[2, 3, 4]
      Outputs:
        atan1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn atanh(graph: &OnnxGraph) {
    let node = find_node(graph, "atanh");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Atanh "atanh1"
      Inputs:
        atanh_input: F32[2, 3, 4]
      Outputs:
        atanh1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn average_pool(graph: &OnnxGraph) {
    let node = find_node(graph, "averagepool2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    AveragePool2d "averagepool2d1"
      Inputs:
        averagepool_input: F32[1, 3, 8, 8]
      Outputs:
        averagepool2d1_out1: F32[?, ?, ?, ?]
      Config:
        AvgPool2dConfig {
            kernel_size: [
                2,
                2,
            ],
            strides: [
                2,
                2,
            ],
            padding: Valid,
            count_include_pad: false,
            dilation: [
                1,
                1,
            ],
            ceil_mode: false,
            auto_pad: NotSet,
        }
    "#);
}

#[rstest]
fn bernoulli(graph: &OnnxGraph) {
    let node = find_node(graph, "bernoulli");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Bernoulli "bernoulli1"
      Inputs:
        bernoulli_input: F32[2, 3]
      Outputs:
        bernoulli1_out1: F32[2, 3]
    "#);
}

#[rstest]
fn conv(graph: &OnnxGraph) {
    let node = find_node(graph, "conv2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Conv2d "conv2d1"
      Inputs:
        conv_input: F32[1, 3, 5, 5]
        _: F32[2, 3, 3, 3] [static(0)]
      Outputs:
        conv2d1_out1: F32[1, 2, 3, 3]
      Config:
        Conv2dConfig {
            kernel_size: [
                3,
                3,
            ],
            stride: [
                1,
                1,
            ],
            padding: Valid,
            dilation: [
                1,
                1,
            ],
            groups: 1,
            auto_pad: NotSet,
        }
    "#);
}

#[rstest]
fn conv_transpose(graph: &OnnxGraph) {
    let node = find_node(graph, "convtranspose2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ConvTranspose2d "convtranspose2d1"
      Inputs:
        convtranspose_input: F32[1, 3, 5, 5]
        _: F32[3, 2, 3, 3] [static(1)]
      Outputs:
        convtranspose2d1_out1: F32[1, 3, 5, 5]
      Config:
        ConvTranspose2dConfig {
            kernel_size: [
                3,
                3,
            ],
            stride: [
                1,
                1,
            ],
            dilation: [
                1,
                1,
            ],
            padding: [
                0,
                0,
            ],
            padding_out: [
                0,
                0,
            ],
            groups: 1,
        }
    "#);
}

#[rstest]
fn cos(graph: &OnnxGraph) {
    let node = find_node(graph, "cos");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Cos "cos1"
      Inputs:
        cos_input: F32[2, 3, 4]
      Outputs:
        cos1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn cosh(graph: &OnnxGraph) {
    let node = find_node(graph, "cosh");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Cosh "cosh1"
      Inputs:
        cosh_input: F32[2, 3, 4]
      Outputs:
        cosh1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn deform_conv(graph: &OnnxGraph) {
    let node = find_node(graph, "deformconv");
    insta::assert_snapshot!(format!("{node}"), @r#"
    DeformConv "deformconv1"
      Inputs:
        deformconv_input: F32[1, 1, 3, 3]
        _: F32[1, 1, 2, 2] [static(2)]
        deformconv_offset: F32[1, 8, 2, 2]
      Outputs:
        deformconv1_out1: F32[1, 1, 2, 2]
      Config:
        DeformConvConfig {
            kernel_size: [
                2,
                2,
            ],
            stride: [
                1,
                1,
            ],
            padding: Valid,
            dilation: [
                1,
                1,
            ],
            groups: 1,
            offset_groups: 1,
        }
    "#);
}

/// Dropout is eliminated during post-processing (no-op).
/// Verify the model parses without error.
#[test]
fn dropout() {
    let _graph = load_model("opset_22.onnx");
}

#[rstest]
fn elu(graph: &OnnxGraph) {
    let node = find_node(graph, "elu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Elu "elu1"
      Inputs:
        elu_input: F32[2, 3, 4]
      Outputs:
        elu1_out1: F32[2, 3, 4]
      Config:
        EluConfig {
            alpha: 1.0,
        }
    "#);
}

#[rstest]
fn eye_like(graph: &OnnxGraph) {
    let node = find_node(graph, "eyelike");
    insta::assert_snapshot!(format!("{node}"), @r#"
    EyeLike "eyelike1"
      Inputs:
        eyelike_input: F32[3, 3]
      Outputs:
        eyelike1_out1: F32[3, 3]
      Config:
        EyeLikeConfig {
            dtype: None,
            k: 0,
        }
    "#);
}

#[rstest]
fn gru(graph: &OnnxGraph) {
    let node = find_node(graph, "gru");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Gru "gru1"
      Inputs:
        gru_input: F32[1, 2, 3]
        _: F32[1, 12, 3] [static(5)]
        _: F32[1, 12, 4] [static(6)]
      Outputs:
        gru1_out1: F32[?, ?, ?, ?]
      Config:
        GruConfig {
            input_size: 3,
            hidden_size: 4,
            direction: Forward,
            has_bias: false,
            has_initial_h: false,
            batch_first: false,
            clip: None,
            linear_before_reset: false,
            gate_activation: Sigmoid,
            hidden_activation: Tanh,
            activation_alpha: None,
            activation_beta: None,
        }
    "#);
}

#[rstest]
fn global_average_pool(graph: &OnnxGraph) {
    let node = find_node(graph, "globalaveragepool");
    insta::assert_snapshot!(format!("{node}"), @r#"
    GlobalAveragePool "globalaveragepool1"
      Inputs:
        globalaveragepool_input: F32[1, 3, 8, 8]
      Outputs:
        globalaveragepool1_out1: F32[1, 3, 8, 8]
    "#);
}

#[rstest]
fn grid_sample(graph: &OnnxGraph) {
    let node = find_node(graph, "gridsample");
    insta::assert_snapshot!(format!("{node}"), @r#"
    GridSample "gridsample1"
      Inputs:
        gridsample_input: F32[1, 1, 3, 3]
        gridsample_grid: F32[1, 2, 2, 2]
      Outputs:
        gridsample1_out1: F32[?, ?, ?, ?]
      Config:
        GridSampleConfig {
            mode: Bilinear,
            padding_mode: Zeros,
            align_corners: false,
        }
    "#);
}

#[rstest]
fn hard_sigmoid(graph: &OnnxGraph) {
    let node = find_node(graph, "hardsigmoid");
    insta::assert_snapshot!(format!("{node}"), @r#"
    HardSigmoid "hardsigmoid1"
      Inputs:
        hardsigmoid_input: F32[2, 3, 4]
      Outputs:
        hardsigmoid1_out1: F32[2, 3, 4]
      Config:
        HardSigmoidConfig {
            alpha: 0.2,
            beta: 0.5,
        }
    "#);
}

#[rstest]
fn hard_swish(graph: &OnnxGraph) {
    let node = find_node(graph, "hardswish");
    insta::assert_snapshot!(format!("{node}"), @r#"
    HardSwish "hardswish1"
      Inputs:
        hardswish_input: F32[2, 3, 4]
      Outputs:
        hardswish1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn instance_normalization(graph: &OnnxGraph) {
    let node = find_node(graph, "instancenormalization");
    insta::assert_snapshot!(format!("{node}"), @r#"
    InstanceNormalization "instancenormalization1"
      Inputs:
        instancenormalization_input: F32[1, 3, 4, 4]
        _: F32[3] [static(7)]
        _: F32[3] [static(8)]
      Outputs:
        instancenormalization1_out1: F32[1, 3, 4, 4]
      Config:
        InstanceNormConfig {
            epsilon: 9.999999747378752e-6,
        }
    "#);
}

#[rstest]
fn lstm(graph: &OnnxGraph) {
    let node = find_node(graph, "lstm");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Lstm "lstm1"
      Inputs:
        lstm_input: F32[1, 2, 3]
        _: F32[1, 16, 3] [static(9)]
        _: F32[1, 16, 4] [static(10)]
      Outputs:
        lstm1_out1: F32[?, ?, ?, ?]
      Config:
        LstmConfig {
            input_size: 3,
            hidden_size: 4,
            direction: Forward,
            has_bias: false,
            has_initial_h: false,
            has_initial_c: false,
            has_peephole: false,
            batch_first: false,
            clip: None,
            input_forget: false,
            gate_activation: Sigmoid,
            cell_activation: Tanh,
            hidden_activation: Tanh,
        }
    "#);
}

#[rstest]
fn max_pool(graph: &OnnxGraph) {
    let node = find_node(graph, "maxpool2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    MaxPool2d "maxpool2d1"
      Inputs:
        maxpool_input: F32[1, 3, 8, 8]
      Outputs:
        maxpool2d1_out1: F32[1, 3, 8, 8]
      Config:
        MaxPool2dConfig {
            kernel_size: [
                2,
                2,
            ],
            strides: [
                2,
                2,
            ],
            padding: Valid,
            dilation: [
                1,
                1,
            ],
            ceil_mode: false,
            auto_pad: NotSet,
        }
    "#);
}

#[rstest]
fn mish(graph: &OnnxGraph) {
    let node = find_node(graph, "mish");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Mish "mish1"
      Inputs:
        mish_input: F32[2, 3, 4]
      Outputs:
        mish1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn random_normal(graph: &OnnxGraph) {
    let node = find_node(graph, "randomnormal");
    insta::assert_snapshot!(format!("{node}"), @r#"
    RandomNormal "randomnormal1"
      Inputs:
      Outputs:
        randomnormal1_out1: F32[?, ?]
      Config:
        RandomNormalConfig {
            mean: 0.0,
            scale: 1.0,
            shape: [
                2,
                3,
            ],
        }
    "#);
}

#[rstest]
fn random_normal_like(graph: &OnnxGraph) {
    let node = find_node(graph, "randomnormallike");
    insta::assert_snapshot!(format!("{node}"), @r#"
    RandomNormalLike "randomnormallike1"
      Inputs:
        randomnormallike_input: F32[2, 3]
      Outputs:
        randomnormallike1_out1: F32[2, 3]
      Config:
        RandomNormalLikeConfig {
            mean: 0.0,
            scale: 1.0,
        }
    "#);
}

#[rstest]
fn random_uniform(graph: &OnnxGraph) {
    let node = find_node(graph, "randomuniform");
    insta::assert_snapshot!(format!("{node}"), @r#"
    RandomUniform "randomuniform1"
      Inputs:
      Outputs:
        randomuniform1_out1: F32[?, ?]
      Config:
        RandomUniformConfig {
            low: 0.0,
            high: 1.0,
            shape: [
                2,
                3,
            ],
        }
    "#);
}

#[rstest]
fn random_uniform_like(graph: &OnnxGraph) {
    let node = find_node(graph, "randomuniformlike");
    insta::assert_snapshot!(format!("{node}"), @r#"
    RandomUniformLike "randomuniformlike1"
      Inputs:
        randomuniformlike_input: F32[2, 3]
      Outputs:
        randomuniformlike1_out1: F32[2, 3]
      Config:
        RandomUniformLikeConfig {
            low: 0.0,
            high: 1.0,
        }
    "#);
}

#[rstest]
fn round(graph: &OnnxGraph) {
    let node = find_node(graph, "round");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Round "round1"
      Inputs:
        round_input: F32[2, 3, 4]
      Outputs:
        round1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn selu(graph: &OnnxGraph) {
    let node = find_node(graph, "selu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Selu "selu1"
      Inputs:
        selu_input: F32[2, 3, 4]
      Outputs:
        selu1_out1: F32[2, 3, 4]
      Config:
        SeluConfig {
            alpha: 1.6732631921768188,
            gamma: 1.0507010221481323,
        }
    "#);
}

#[rstest]
fn sin(graph: &OnnxGraph) {
    let node = find_node(graph, "sin");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sin "sin1"
      Inputs:
        sin_input: F32[2, 3, 4]
      Outputs:
        sin1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn sinh(graph: &OnnxGraph) {
    let node = find_node(graph, "sinh");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sinh "sinh1"
      Inputs:
        sinh_input: F32[2, 3, 4]
      Outputs:
        sinh1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn softplus(graph: &OnnxGraph) {
    let node = find_node(graph, "softplus");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Softplus "softplus1"
      Inputs:
        softplus_input: F32[2, 3, 4]
      Outputs:
        softplus1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn softsign(graph: &OnnxGraph) {
    let node = find_node(graph, "softsign");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Softsign "softsign1"
      Inputs:
        softsign_input: F32[2, 3, 4]
      Outputs:
        softsign1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn tan(graph: &OnnxGraph) {
    let node = find_node(graph, "tan");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Tan "tan1"
      Inputs:
        tan_input: F32[2, 3, 4]
      Outputs:
        tan1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn thresholded_relu(graph: &OnnxGraph) {
    let node = find_node(graph, "thresholdedrelu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ThresholdedRelu "thresholdedrelu1"
      Inputs:
        thresholdedrelu_input: F32[2, 3, 4]
      Outputs:
        thresholdedrelu1_out1: F32[2, 3, 4]
      Config:
        ThresholdedReluConfig {
            alpha: 1.0,
        }
    "#);
}

