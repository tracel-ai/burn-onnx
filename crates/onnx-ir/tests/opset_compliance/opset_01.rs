//! Opset 1 compliance tests.
//!
//! Auto-generated by gen_rust_tests.py. Edit the generator, not this file.

use super::helpers::*;

#[test]
fn and_op() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "and");
    insta::assert_snapshot!(format!("{node}"), @r#"
    And "and1"
      Inputs:
        and_a: Bool[2, 3, 4]
        and_b: Bool[2, 3, 4]
      Outputs:
        and1_out1: Bool[2, 3, 4]
    "#);
}

#[test]
fn cast() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "cast");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Cast "cast1"
      Inputs:
        cast_input: F32[2, 3]
      Outputs:
        cast1_out1: I32[2, 3]
      Config:
        CastConfig {
            to: I32,
        }
    "#);
}

#[test]
fn constant() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "constant");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Constant "constant5"
      Inputs:
        _: I64[2] [static(4)]
      Outputs:
        constant5_out1: I64[2] [constant]
    "#);
}

#[test]
fn conv() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "conv2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Conv2d "conv2d1"
      Inputs:
        conv_input: F32[1, 3, 5, 5]
        _: F32[2, 3, 3, 3] [static(0)]
      Outputs:
        conv2d1_out1: F32[1, 2, 3, 3]
      Config:
        Conv2dConfig {
            kernel_size: [
                3,
                3,
            ],
            stride: [
                1,
                1,
            ],
            padding: Valid,
            dilation: [
                1,
                1,
            ],
            groups: 1,
            auto_pad: NotSet,
        }
    "#);
}

#[test]
fn conv_transpose() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "convtranspose2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ConvTranspose2d "convtranspose2d1"
      Inputs:
        convtranspose_input: F32[1, 3, 5, 5]
        _: F32[3, 2, 3, 3] [static(1)]
      Outputs:
        convtranspose2d1_out1: F32[1, 3, 5, 5]
      Config:
        ConvTranspose2dConfig {
            kernel_size: [
                3,
                3,
            ],
            stride: [
                1,
                1,
            ],
            dilation: [
                1,
                1,
            ],
            padding: [
                0,
                0,
            ],
            padding_out: [
                0,
                0,
            ],
            groups: 1,
        }
    "#);
}

#[test]
fn depth_to_space() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "depthtospace");
    insta::assert_snapshot!(format!("{node}"), @r#"
    DepthToSpace "depthtospace1"
      Inputs:
        depthtospace_input: F32[1, 8, 2, 2]
      Outputs:
        depthtospace1_out1: F32[1, 2, 4, 4]
      Config:
        DepthToSpaceConfig {
            mode: Dcr,
            block_size: 2,
        }
    "#);
}

/// Dropout is eliminated during post-processing (no-op).
/// Verify the model parses without error.
#[test]
fn dropout() {
    let _graph = load_model("opset_01.onnx");
}

#[test]
fn elu() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "elu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Elu "elu1"
      Inputs:
        elu_input: F32[2, 3, 4]
      Outputs:
        elu1_out1: F32[2, 3, 4]
      Config:
        EluConfig {
            alpha: 1.0,
        }
    "#);
}

#[test]
fn flatten() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "flatten");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Flatten "flatten1"
      Inputs:
        flatten_input: F32[2, 3, 4]
      Outputs:
        flatten1_out1: F32[2, 12]
      Config:
        FlattenConfig {
            axis: 1,
        }
    "#);
}

#[test]
fn gru() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "gru");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Gru "gru1"
      Inputs:
        gru_input: F32[1, 2, 3]
        _: F32[1, 12, 3] [static(2)]
        _: F32[1, 12, 4] [static(3)]
      Outputs:
        gru1_out1: F32[?, ?, ?, ?]
      Config:
        GruConfig {
            input_size: 3,
            hidden_size: 4,
            direction: Forward,
            has_bias: false,
            has_initial_h: false,
            batch_first: false,
            clip: None,
            linear_before_reset: false,
            gate_activation: Sigmoid,
            hidden_activation: Tanh,
            activation_alpha: None,
            activation_beta: None,
        }
    "#);
}

#[test]
fn gather() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "gather");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Gather "gather1"
      Inputs:
        gather_input: F32[3, 4]
        constant5_out1: I64[2] [constant]
      Outputs:
        gather1_out1: F32[?, ?]
      Config:
        GatherConfig {
            axis: 0,
        }
    "#);
}

#[test]
fn global_average_pool() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "globalaveragepool");
    insta::assert_snapshot!(format!("{node}"), @r#"
    GlobalAveragePool "globalaveragepool1"
      Inputs:
        globalaveragepool_input: F32[1, 3, 8, 8]
      Outputs:
        globalaveragepool1_out1: F32[1, 3, 8, 8]
    "#);
}

/// Identity is eliminated during post-processing (no-op).
/// Verify the model parses without error.
#[test]
fn identity() {
    let _graph = load_model("opset_01.onnx");
}

#[test]
fn if_op() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "if");
    insta::assert_snapshot!(format!("{node}"), @r#"
    If "if1"
      Inputs:
        if_condition: Scalar(Bool)
      Outputs:
        if1_out1: F32[2, 3]
      Config:
        IfConfig {
            then_branch: OnnxGraph {
                nodes: [
                    Constant(
                        ConstantNode {
                            name: "constant12",
                            inputs: [
                                Argument {
                                    name: "",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Static(
                                        0,
                                    ),
                                },
                            ],
                            outputs: [
                                Argument {
                                    name: "constant12_out1",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Constant,
                                },
                            ],
                        },
                    ),
                ],
                inputs: [],
                outputs: [
                    Argument {
                        name: "constant12_out1",
                        ty: Tensor(
                            TensorType {
                                dtype: F32,
                                rank: 2,
                                static_shape: Some(
                                    [
                                        Some(
                                            2,
                                        ),
                                        Some(
                                            3,
                                        ),
                                    ],
                                ),
                            },
                        ),
                        value_source: Constant,
                    },
                ],
                value_store: Some(
                    ValueStore {
                        tensor_store: TensorStore {
                            data: {
                                0: TensorDataRef {
                                    shape: [
                                        2,
                                        3,
                                    ],
                                    dtype: F32,
                                    source: Embedded(
                                        b"\0\0\x80?\0\0\x80?\0\0\x80?\0\0\x80?\0\0\x80?\0\0\x80?",
                                    ),
                                },
                            },
                            next_id: 1,
                        },
                        constant_map: {
                            "constant12_out1": 0,
                        },
                    },
                ),
            },
            else_branch: OnnxGraph {
                nodes: [
                    Constant(
                        ConstantNode {
                            name: "constant13",
                            inputs: [
                                Argument {
                                    name: "",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Static(
                                        0,
                                    ),
                                },
                            ],
                            outputs: [
                                Argument {
                                    name: "constant13_out1",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Constant,
                                },
                            ],
                        },
                    ),
                ],
                inputs: [],
                outputs: [
                    Argument {
                        name: "constant13_out1",
                        ty: Tensor(
                            TensorType {
                                dtype: F32,
                                rank: 2,
                                static_shape: Some(
                                    [
                                        Some(
                                            2,
                                        ),
                                        Some(
                                            3,
                                        ),
                                    ],
                                ),
                            },
                        ),
                        value_source: Constant,
                    },
                ],
                value_store: Some(
                    ValueStore {
                        tensor_store: TensorStore {
                            data: {
                                0: TensorDataRef {
                                    shape: [
                                        2,
                                        3,
                                    ],
                                    dtype: F32,
                                    source: Embedded(
                                        b"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                                    ),
                                },
                            },
                            next_id: 1,
                        },
                        constant_map: {
                            "constant13_out1": 0,
                        },
                    },
                ),
            },
            scope_ref_names: [],
        }
    "#);
}

#[test]
fn lstm() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "lstm");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Lstm "lstm1"
      Inputs:
        lstm_input: F32[1, 2, 3]
        _: F32[1, 16, 3] [static(5)]
        _: F32[1, 16, 4] [static(6)]
      Outputs:
        lstm1_out1: F32[?, ?, ?, ?]
      Config:
        LstmConfig {
            input_size: 3,
            hidden_size: 4,
            direction: Forward,
            has_bias: false,
            has_initial_h: false,
            has_initial_c: false,
            has_peephole: false,
            batch_first: false,
            clip: None,
            input_forget: false,
            gate_activation: Sigmoid,
            cell_activation: Tanh,
            hidden_activation: Tanh,
        }
    "#);
}

#[test]
fn mat_mul() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "matmul");
    insta::assert_snapshot!(format!("{node}"), @r#"
    MatMul "matmul1"
      Inputs:
        matmul_a: F32[2, 3]
        matmul_b: F32[3, 4]
      Outputs:
        matmul1_out1: F32[?, ?]
    "#);
}

#[test]
fn max() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "max");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Max "max1"
      Inputs:
        max_a: F32[2, 3, 4]
        max_b: F32[2, 3, 4]
      Outputs:
        max1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn max_pool() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "maxpool2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    MaxPool2d "maxpool2d1"
      Inputs:
        maxpool_input: F32[1, 3, 8, 8]
      Outputs:
        maxpool2d1_out1: F32[1, 3, 8, 8]
      Config:
        MaxPool2dConfig {
            kernel_size: [
                2,
                2,
            ],
            strides: [
                2,
                2,
            ],
            padding: Valid,
            dilation: [
                1,
                1,
            ],
            ceil_mode: false,
            auto_pad: NotSet,
        }
    "#);
}

#[test]
fn min() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "min");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Min "min1"
      Inputs:
        min_a: F32[2, 3, 4]
        min_b: F32[2, 3, 4]
      Outputs:
        min1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn not_op() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "not");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Not "not1"
      Inputs:
        not_input: Bool[2, 3, 4]
      Outputs:
        not1_out1: Bool[2, 3, 4]
    "#);
}

#[test]
fn or_op() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "or");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Or "or1"
      Inputs:
        or_a: Bool[2, 3, 4]
        or_b: Bool[2, 3, 4]
      Outputs:
        or1_out1: Bool[2, 3, 4]
    "#);
}

#[test]
fn pow() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "pow");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Pow "pow1"
      Inputs:
        pow_a: F32[2, 3, 4]
        pow_b: F32[2, 3, 4]
      Outputs:
        pow1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn random_normal() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "randomnormal");
    insta::assert_snapshot!(format!("{node}"), @r#"
    RandomNormal "randomnormal1"
      Inputs:
      Outputs:
        randomnormal1_out1: F32[?, ?]
      Config:
        RandomNormalConfig {
            mean: 0.0,
            scale: 1.0,
            shape: [
                2,
                3,
            ],
        }
    "#);
}

#[test]
fn random_normal_like() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "randomnormallike");
    insta::assert_snapshot!(format!("{node}"), @r#"
    RandomNormalLike "randomnormallike1"
      Inputs:
        randomnormallike_input: F32[2, 3]
      Outputs:
        randomnormallike1_out1: F32[2, 3]
      Config:
        RandomNormalLikeConfig {
            mean: 0.0,
            scale: 1.0,
        }
    "#);
}

#[test]
fn random_uniform() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "randomuniform");
    insta::assert_snapshot!(format!("{node}"), @r#"
    RandomUniform "randomuniform1"
      Inputs:
      Outputs:
        randomuniform1_out1: F32[?, ?]
      Config:
        RandomUniformConfig {
            low: 0.0,
            high: 1.0,
            shape: [
                2,
                3,
            ],
        }
    "#);
}

#[test]
fn random_uniform_like() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "randomuniformlike");
    insta::assert_snapshot!(format!("{node}"), @r#"
    RandomUniformLike "randomuniformlike1"
      Inputs:
        randomuniformlike_input: F32[2, 3]
      Outputs:
        randomuniformlike1_out1: F32[2, 3]
      Config:
        RandomUniformLikeConfig {
            low: 0.0,
            high: 1.0,
        }
    "#);
}

#[test]
fn selu() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "selu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Selu "selu1"
      Inputs:
        selu_input: F32[2, 3, 4]
      Outputs:
        selu1_out1: F32[2, 3, 4]
      Config:
        SeluConfig {
            alpha: 1.6732631921768188,
            gamma: 1.0507010221481323,
        }
    "#);
}

#[test]
fn shape() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "shape");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Shape "shape1"
      Inputs:
        shape_input: F32[2, 3, 4]
      Outputs:
        shape1_out1: Shape(3)
      Config:
        ShapeConfig {
            start: 0,
            end: 3,
        }
    "#);
}

#[test]
fn size() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "size");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Size "size1"
      Inputs:
        size_input: F32[2, 3, 4]
      Outputs:
        size1_out1: Scalar(I64)
    "#);
}

#[test]
fn softplus() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "softplus");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Softplus "softplus1"
      Inputs:
        softplus_input: F32[2, 3, 4]
      Outputs:
        softplus1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn softsign() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "softsign");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Softsign "softsign1"
      Inputs:
        softsign_input: F32[2, 3, 4]
      Outputs:
        softsign1_out1: F32[2, 3, 4]
    "#);
}

#[test]
fn space_to_depth() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "spacetodepth");
    insta::assert_snapshot!(format!("{node}"), @r#"
    SpaceToDepth "spacetodepth1"
      Inputs:
        spacetodepth_input: F32[1, 2, 4, 4]
      Outputs:
        spacetodepth1_out1: F32[1, 8, 2, 2]
      Config:
        SpaceToDepthConfig {
            block_size: 2,
        }
    "#);
}

#[test]
fn transpose() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "transpose");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Transpose "transpose1"
      Inputs:
        transpose_input: F32[2, 3, 4]
      Outputs:
        transpose1_out1: F32[4, 3, 2]
      Config:
        TransposeConfig {
            perm: [
                2,
                1,
                0,
            ],
        }
    "#);
}

#[test]
fn xor_op() {
    let graph = load_model("opset_01.onnx");
    let node = find_node(&graph, "xor");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Xor "xor1"
      Inputs:
        xor_a: Bool[2, 3, 4]
        xor_b: Bool[2, 3, 4]
      Outputs:
        xor1_out1: Bool[2, 3, 4]
    "#);
}

/// Ops that require min_opset > 1: Abs, Add, ArgMax, ArgMin, AveragePool, BatchNormalization, Ceil, Clip, Concat, Div, Equal, Exp, Floor, Gemm, Greater, HardSigmoid, Hardmax, InstanceNormalization, LeakyRelu, Less, Log, LogSoftmax, Mean, Mul, Neg, PRelu, Pad, Reciprocal, ReduceL1, ReduceL2, ReduceLogSum, ReduceLogSumExp, ReduceMax, ReduceMean, ReduceMin, ReduceProd, ReduceSum, ReduceSumSquare, Relu, Reshape, Sigmoid, Slice, Softmax, Split, Sqrt, Squeeze, Sub, Sum, Tanh, Tile, TopK, Unsqueeze
#[test]
fn unsupported_ops_fail() {
    let result = load_model_result("opset_01_unsupported.onnx");
    assert!(result.is_err(), "expected parse failure for unsupported ops at opset 1");
}

