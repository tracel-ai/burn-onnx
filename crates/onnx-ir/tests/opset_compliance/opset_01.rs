//! Opset 1 compliance tests.
//!
//! Auto-generated by gen_rust_tests.py. Edit the generator, not this file.

use super::helpers::*;
use rstest::*;

#[fixture]
#[once]
fn graph() -> OnnxGraph {
    load_model("opset_01.onnx")
}

#[rstest]
fn abs(graph: &OnnxGraph) {
    let node = find_node(graph, "abs");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Abs "abs1"
      Inputs:
        abs_input: F32[2, 3, 4]
      Outputs:
        abs1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn and_op(graph: &OnnxGraph) {
    let node = find_node(graph, "and");
    insta::assert_snapshot!(format!("{node}"), @r#"
    And "and1"
      Inputs:
        and_a: Bool[2, 3, 4]
        and_b: Bool[2, 3, 4]
      Outputs:
        and1_out1: Bool[2, 3, 4]
    "#);
}

#[rstest]
fn arg_max(graph: &OnnxGraph) {
    let node = find_node(graph, "argmax");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ArgMax "argmax1"
      Inputs:
        argmax_input: F32[2, 3, 4]
      Outputs:
        argmax1_out1: I64[?, ?, ?]
      Config:
        ArgMaxConfig {
            axis: 1,
            keepdims: true,
        }
    "#);
}

#[rstest]
fn arg_min(graph: &OnnxGraph) {
    let node = find_node(graph, "argmin");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ArgMin "argmin1"
      Inputs:
        argmin_input: F32[2, 3, 4]
      Outputs:
        argmin1_out1: I64[?, ?, ?]
      Config:
        ArgMinConfig {
            axis: 1,
            keepdims: true,
        }
    "#);
}

#[rstest]
fn cast(graph: &OnnxGraph) {
    let node = find_node(graph, "cast");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Cast "cast1"
      Inputs:
        cast_input: F32[2, 3]
      Outputs:
        cast1_out1: I32[2, 3]
      Config:
        CastConfig {
            to: I32,
        }
    "#);
}

#[rstest]
fn ceil(graph: &OnnxGraph) {
    let node = find_node(graph, "ceil");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Ceil "ceil1"
      Inputs:
        ceil_input: F32[2, 3, 4]
      Outputs:
        ceil1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn clip(graph: &OnnxGraph) {
    let node = find_node(graph, "clip");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Clip "clip1"
      Inputs:
        clip_input: F32[2, 3, 4]
      Outputs:
        clip1_out1: F32[2, 3, 4]
      Config:
        ClipConfig {
            min: Some(
                Static(
                    0.0,
                ),
            ),
            max: Some(
                Static(
                    6.0,
                ),
            ),
        }
    "#);
}

#[rstest]
fn concat(graph: &OnnxGraph) {
    let node = find_node(graph, "concat");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Concat "concat1"
      Inputs:
        concat_a: F32[2, 3]
        concat_b: F32[2, 3]
      Outputs:
        concat1_out1: F32[?, ?]
      Config:
        ConcatConfig {
            axis: 0,
        }
    "#);
}

#[rstest]
fn constant(graph: &OnnxGraph) {
    let node = find_node(graph, "constant");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Constant "constant5"
      Inputs:
        _: I64[2] [static(4)]
      Outputs:
        constant5_out1: I64[2] [constant]
    "#);
}

#[rstest]
fn conv(graph: &OnnxGraph) {
    let node = find_node(graph, "conv2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Conv2d "conv2d1"
      Inputs:
        conv_input: F32[1, 3, 5, 5]
        _: F32[2, 3, 3, 3] [static(0)]
      Outputs:
        conv2d1_out1: F32[1, 2, 3, 3]
      Config:
        Conv2dConfig {
            kernel_size: [
                3,
                3,
            ],
            stride: [
                1,
                1,
            ],
            padding: Valid,
            dilation: [
                1,
                1,
            ],
            groups: 1,
            auto_pad: NotSet,
        }
    "#);
}

#[rstest]
fn conv_transpose(graph: &OnnxGraph) {
    let node = find_node(graph, "convtranspose2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ConvTranspose2d "convtranspose2d1"
      Inputs:
        convtranspose_input: F32[1, 3, 5, 5]
        _: F32[3, 2, 3, 3] [static(1)]
      Outputs:
        convtranspose2d1_out1: F32[1, 3, 5, 5]
      Config:
        ConvTranspose2dConfig {
            kernel_size: [
                3,
                3,
            ],
            stride: [
                1,
                1,
            ],
            dilation: [
                1,
                1,
            ],
            padding: [
                0,
                0,
            ],
            padding_out: [
                0,
                0,
            ],
            groups: 1,
        }
    "#);
}

#[rstest]
fn depth_to_space(graph: &OnnxGraph) {
    let node = find_node(graph, "depthtospace");
    insta::assert_snapshot!(format!("{node}"), @r#"
    DepthToSpace "depthtospace1"
      Inputs:
        depthtospace_input: F32[1, 8, 2, 2]
      Outputs:
        depthtospace1_out1: F32[1, 2, 4, 4]
      Config:
        DepthToSpaceConfig {
            mode: Dcr,
            block_size: 2,
        }
    "#);
}

/// Dropout is eliminated during post-processing (no-op).
/// Verify the model parses without error.
#[test]
fn dropout() {
    let _graph = load_model("opset_01.onnx");
}

#[rstest]
fn elu(graph: &OnnxGraph) {
    let node = find_node(graph, "elu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Elu "elu1"
      Inputs:
        elu_input: F32[2, 3, 4]
      Outputs:
        elu1_out1: F32[2, 3, 4]
      Config:
        EluConfig {
            alpha: 1.0,
        }
    "#);
}

#[rstest]
fn exp(graph: &OnnxGraph) {
    let node = find_node(graph, "exp");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Exp "exp1"
      Inputs:
        exp_input: F32[2, 3, 4]
      Outputs:
        exp1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn flatten(graph: &OnnxGraph) {
    let node = find_node(graph, "flatten");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Flatten "flatten1"
      Inputs:
        flatten_input: F32[2, 3, 4]
      Outputs:
        flatten1_out1: F32[2, 12]
      Config:
        FlattenConfig {
            axis: 1,
        }
    "#);
}

#[rstest]
fn floor(graph: &OnnxGraph) {
    let node = find_node(graph, "floor");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Floor "floor1"
      Inputs:
        floor_input: F32[2, 3, 4]
      Outputs:
        floor1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn gru(graph: &OnnxGraph) {
    let node = find_node(graph, "gru");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Gru "gru1"
      Inputs:
        gru_input: F32[1, 2, 3]
        _: F32[1, 12, 3] [static(2)]
        _: F32[1, 12, 4] [static(3)]
      Outputs:
        gru1_out1: F32[?, ?, ?, ?]
      Config:
        GruConfig {
            input_size: 3,
            hidden_size: 4,
            direction: Forward,
            has_bias: false,
            has_initial_h: false,
            batch_first: false,
            clip: None,
            linear_before_reset: false,
            gate_activation: Sigmoid,
            hidden_activation: Tanh,
            activation_alpha: None,
            activation_beta: None,
        }
    "#);
}

#[rstest]
fn gather(graph: &OnnxGraph) {
    let node = find_node(graph, "gather");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Gather "gather1"
      Inputs:
        gather_input: F32[3, 4]
        constant5_out1: I64[2] [constant]
      Outputs:
        gather1_out1: F32[?, ?]
      Config:
        GatherConfig {
            axis: 0,
        }
    "#);
}

#[rstest]
fn global_average_pool(graph: &OnnxGraph) {
    let node = find_node(graph, "globalaveragepool");
    insta::assert_snapshot!(format!("{node}"), @r#"
    GlobalAveragePool "globalaveragepool1"
      Inputs:
        globalaveragepool_input: F32[1, 3, 8, 8]
      Outputs:
        globalaveragepool1_out1: F32[1, 3, 8, 8]
    "#);
}

#[rstest]
fn hard_sigmoid(graph: &OnnxGraph) {
    let node = find_node(graph, "hardsigmoid");
    insta::assert_snapshot!(format!("{node}"), @r#"
    HardSigmoid "hardsigmoid1"
      Inputs:
        hardsigmoid_input: F32[2, 3, 4]
      Outputs:
        hardsigmoid1_out1: F32[2, 3, 4]
      Config:
        HardSigmoidConfig {
            alpha: 0.2,
            beta: 0.5,
        }
    "#);
}

/// Identity is eliminated during post-processing (no-op).
/// Verify the model parses without error.
#[test]
fn identity() {
    let _graph = load_model("opset_01.onnx");
}

#[rstest]
fn if_op(graph: &OnnxGraph) {
    let node = find_node(graph, "if");
    insta::assert_snapshot!(format!("{node}"), @r#"
    If "if1"
      Inputs:
        if_condition: Scalar(Bool)
      Outputs:
        if1_out1: F32[2, 3]
      Config:
        IfConfig {
            then_branch: OnnxGraph {
                nodes: [
                    Constant(
                        ConstantNode {
                            name: "constant15",
                            inputs: [
                                Argument {
                                    name: "",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Static(
                                        0,
                                    ),
                                },
                            ],
                            outputs: [
                                Argument {
                                    name: "constant15_out1",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Constant,
                                },
                            ],
                        },
                    ),
                ],
                inputs: [],
                outputs: [
                    Argument {
                        name: "constant15_out1",
                        ty: Tensor(
                            TensorType {
                                dtype: F32,
                                rank: 2,
                                static_shape: Some(
                                    [
                                        Some(
                                            2,
                                        ),
                                        Some(
                                            3,
                                        ),
                                    ],
                                ),
                            },
                        ),
                        value_source: Constant,
                    },
                ],
                value_store: Some(
                    ValueStore {
                        tensor_store: TensorStore {
                            data: {
                                0: TensorDataRef {
                                    shape: [
                                        2,
                                        3,
                                    ],
                                    dtype: F32,
                                    source: Embedded(
                                        b"\0\0\x80?\0\0\x80?\0\0\x80?\0\0\x80?\0\0\x80?\0\0\x80?",
                                    ),
                                },
                            },
                            next_id: 1,
                        },
                        constant_map: {
                            "constant15_out1": 0,
                        },
                    },
                ),
            },
            else_branch: OnnxGraph {
                nodes: [
                    Constant(
                        ConstantNode {
                            name: "constant16",
                            inputs: [
                                Argument {
                                    name: "",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Static(
                                        0,
                                    ),
                                },
                            ],
                            outputs: [
                                Argument {
                                    name: "constant16_out1",
                                    ty: Tensor(
                                        TensorType {
                                            dtype: F32,
                                            rank: 2,
                                            static_shape: Some(
                                                [
                                                    Some(
                                                        2,
                                                    ),
                                                    Some(
                                                        3,
                                                    ),
                                                ],
                                            ),
                                        },
                                    ),
                                    value_source: Constant,
                                },
                            ],
                        },
                    ),
                ],
                inputs: [],
                outputs: [
                    Argument {
                        name: "constant16_out1",
                        ty: Tensor(
                            TensorType {
                                dtype: F32,
                                rank: 2,
                                static_shape: Some(
                                    [
                                        Some(
                                            2,
                                        ),
                                        Some(
                                            3,
                                        ),
                                    ],
                                ),
                            },
                        ),
                        value_source: Constant,
                    },
                ],
                value_store: Some(
                    ValueStore {
                        tensor_store: TensorStore {
                            data: {
                                0: TensorDataRef {
                                    shape: [
                                        2,
                                        3,
                                    ],
                                    dtype: F32,
                                    source: Embedded(
                                        b"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
                                    ),
                                },
                            },
                            next_id: 1,
                        },
                        constant_map: {
                            "constant16_out1": 0,
                        },
                    },
                ),
            },
            scope_ref_names: [],
        }
    "#);
}

#[rstest]
fn instance_normalization(graph: &OnnxGraph) {
    let node = find_node(graph, "instancenormalization");
    insta::assert_snapshot!(format!("{node}"), @r#"
    InstanceNormalization "instancenormalization1"
      Inputs:
        instancenormalization_input: F32[1, 3, 4, 4]
        _: F32[3] [static(5)]
        _: F32[3] [static(6)]
      Outputs:
        instancenormalization1_out1: F32[1, 3, 4, 4]
      Config:
        InstanceNormConfig {
            epsilon: 9.999999747378752e-6,
        }
    "#);
}

#[rstest]
fn lstm(graph: &OnnxGraph) {
    let node = find_node(graph, "lstm");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Lstm "lstm1"
      Inputs:
        lstm_input: F32[1, 2, 3]
        _: F32[1, 16, 3] [static(7)]
        _: F32[1, 16, 4] [static(8)]
      Outputs:
        lstm1_out1: F32[?, ?, ?, ?]
      Config:
        LstmConfig {
            input_size: 3,
            hidden_size: 4,
            direction: Forward,
            has_bias: false,
            has_initial_h: false,
            has_initial_c: false,
            has_peephole: false,
            batch_first: false,
            clip: None,
            input_forget: false,
            gate_activation: Sigmoid,
            cell_activation: Tanh,
            hidden_activation: Tanh,
        }
    "#);
}

#[rstest]
fn leaky_relu(graph: &OnnxGraph) {
    let node = find_node(graph, "leakyrelu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    LeakyRelu "leakyrelu1"
      Inputs:
        leakyrelu_input: F32[2, 3, 4]
      Outputs:
        leakyrelu1_out1: F32[2, 3, 4]
      Config:
        LeakyReluConfig {
            alpha: 0.009999999776482582,
        }
    "#);
}

#[rstest]
fn log(graph: &OnnxGraph) {
    let node = find_node(graph, "log");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Log "log1"
      Inputs:
        log_input: F32[2, 3, 4]
      Outputs:
        log1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn mat_mul(graph: &OnnxGraph) {
    let node = find_node(graph, "matmul");
    insta::assert_snapshot!(format!("{node}"), @r#"
    MatMul "matmul1"
      Inputs:
        matmul_a: F32[2, 3]
        matmul_b: F32[3, 4]
      Outputs:
        matmul1_out1: F32[?, ?]
    "#);
}

#[rstest]
fn max(graph: &OnnxGraph) {
    let node = find_node(graph, "max");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Max "max1"
      Inputs:
        max_a: F32[2, 3, 4]
        max_b: F32[2, 3, 4]
      Outputs:
        max1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn max_pool(graph: &OnnxGraph) {
    let node = find_node(graph, "maxpool2d");
    insta::assert_snapshot!(format!("{node}"), @r#"
    MaxPool2d "maxpool2d1"
      Inputs:
        maxpool_input: F32[1, 3, 8, 8]
      Outputs:
        maxpool2d1_out1: F32[1, 3, 8, 8]
      Config:
        MaxPool2dConfig {
            kernel_size: [
                2,
                2,
            ],
            strides: [
                2,
                2,
            ],
            padding: Valid,
            dilation: [
                1,
                1,
            ],
            ceil_mode: false,
            auto_pad: NotSet,
        }
    "#);
}

#[rstest]
fn min(graph: &OnnxGraph) {
    let node = find_node(graph, "min");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Min "min1"
      Inputs:
        min_a: F32[2, 3, 4]
        min_b: F32[2, 3, 4]
      Outputs:
        min1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn neg(graph: &OnnxGraph) {
    let node = find_node(graph, "neg");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Neg "neg1"
      Inputs:
        neg_input: F32[2, 3, 4]
      Outputs:
        neg1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn not_op(graph: &OnnxGraph) {
    let node = find_node(graph, "not");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Not "not1"
      Inputs:
        not_input: Bool[2, 3, 4]
      Outputs:
        not1_out1: Bool[2, 3, 4]
    "#);
}

#[rstest]
fn or_op(graph: &OnnxGraph) {
    let node = find_node(graph, "or");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Or "or1"
      Inputs:
        or_a: Bool[2, 3, 4]
        or_b: Bool[2, 3, 4]
      Outputs:
        or1_out1: Bool[2, 3, 4]
    "#);
}

#[rstest]
fn p_relu(graph: &OnnxGraph) {
    let node = find_node(graph, "prelu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    PRelu "prelu1"
      Inputs:
        prelu_input: F32[2, 3, 4]
        _: F32[1] [static(9)]
      Outputs:
        prelu1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn pow(graph: &OnnxGraph) {
    let node = find_node(graph, "pow");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Pow "pow1"
      Inputs:
        pow_a: F32[2, 3, 4]
        pow_b: F32[2, 3, 4]
      Outputs:
        pow1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn random_normal(graph: &OnnxGraph) {
    let node = find_node(graph, "randomnormal");
    insta::assert_snapshot!(format!("{node}"), @r#"
    RandomNormal "randomnormal1"
      Inputs:
      Outputs:
        randomnormal1_out1: F32[?, ?]
      Config:
        RandomNormalConfig {
            mean: 0.0,
            scale: 1.0,
            shape: [
                2,
                3,
            ],
        }
    "#);
}

#[rstest]
fn random_normal_like(graph: &OnnxGraph) {
    let node = find_node(graph, "randomnormallike");
    insta::assert_snapshot!(format!("{node}"), @r#"
    RandomNormalLike "randomnormallike1"
      Inputs:
        randomnormallike_input: F32[2, 3]
      Outputs:
        randomnormallike1_out1: F32[2, 3]
      Config:
        RandomNormalLikeConfig {
            mean: 0.0,
            scale: 1.0,
        }
    "#);
}

#[rstest]
fn random_uniform(graph: &OnnxGraph) {
    let node = find_node(graph, "randomuniform");
    insta::assert_snapshot!(format!("{node}"), @r#"
    RandomUniform "randomuniform1"
      Inputs:
      Outputs:
        randomuniform1_out1: F32[?, ?]
      Config:
        RandomUniformConfig {
            low: 0.0,
            high: 1.0,
            shape: [
                2,
                3,
            ],
        }
    "#);
}

#[rstest]
fn random_uniform_like(graph: &OnnxGraph) {
    let node = find_node(graph, "randomuniformlike");
    insta::assert_snapshot!(format!("{node}"), @r#"
    RandomUniformLike "randomuniformlike1"
      Inputs:
        randomuniformlike_input: F32[2, 3]
      Outputs:
        randomuniformlike1_out1: F32[2, 3]
      Config:
        RandomUniformLikeConfig {
            low: 0.0,
            high: 1.0,
        }
    "#);
}

#[rstest]
fn reciprocal(graph: &OnnxGraph) {
    let node = find_node(graph, "reciprocal");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Reciprocal "reciprocal1"
      Inputs:
        reciprocal_input: F32[2, 3, 4]
      Outputs:
        reciprocal1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn reduce_l1(graph: &OnnxGraph) {
    let node = find_node(graph, "reducel1");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceL1 "reducel11"
      Inputs:
        reducel1_input: F32[2, 3, 4]
      Outputs:
        reducel11_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_l2(graph: &OnnxGraph) {
    let node = find_node(graph, "reducel2");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceL2 "reducel21"
      Inputs:
        reducel2_input: F32[2, 3, 4]
      Outputs:
        reducel21_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_log_sum(graph: &OnnxGraph) {
    let node = find_node(graph, "reducelogsum");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceLogSum "reducelogsum1"
      Inputs:
        reducelogsum_input: F32[2, 3, 4]
      Outputs:
        reducelogsum1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_log_sum_exp(graph: &OnnxGraph) {
    let node = find_node(graph, "reducelogsumexp");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceLogSumExp "reducelogsumexp1"
      Inputs:
        reducelogsumexp_input: F32[2, 3, 4]
      Outputs:
        reducelogsumexp1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_max(graph: &OnnxGraph) {
    let node = find_node(graph, "reducemax");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceMax "reducemax1"
      Inputs:
        reducemax_input: F32[2, 3, 4]
      Outputs:
        reducemax1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_mean(graph: &OnnxGraph) {
    let node = find_node(graph, "reducemean");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceMean "reducemean1"
      Inputs:
        reducemean_input: F32[2, 3, 4]
      Outputs:
        reducemean1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_min(graph: &OnnxGraph) {
    let node = find_node(graph, "reducemin");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceMin "reducemin1"
      Inputs:
        reducemin_input: F32[2, 3, 4]
      Outputs:
        reducemin1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_prod(graph: &OnnxGraph) {
    let node = find_node(graph, "reduceprod");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceProd "reduceprod1"
      Inputs:
        reduceprod_input: F32[2, 3, 4]
      Outputs:
        reduceprod1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_sum(graph: &OnnxGraph) {
    let node = find_node(graph, "reducesum");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceSum "reducesum1"
      Inputs:
        reducesum_input: F32[2, 3, 4]
      Outputs:
        reducesum1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn reduce_sum_square(graph: &OnnxGraph) {
    let node = find_node(graph, "reducesumsquare");
    insta::assert_snapshot!(format!("{node}"), @r#"
    ReduceSumSquare "reducesumsquare1"
      Inputs:
        reducesumsquare_input: F32[2, 3, 4]
      Outputs:
        reducesumsquare1_out1: F32[2, 1, 4]
      Config:
        ReduceConfig {
            dims: [
                1,
            ],
            keepdims: true,
        }
    "#);
}

#[rstest]
fn relu(graph: &OnnxGraph) {
    let node = find_node(graph, "relu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Relu "relu1"
      Inputs:
        relu_input: F32[2, 3, 4]
      Outputs:
        relu1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn reshape(graph: &OnnxGraph) {
    let node = find_node(graph, "reshape");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Reshape "reshape1"
      Inputs:
        reshape_input: F32[2, 3, 4]
      Outputs:
        reshape1_out1: F32[6, 4]
      Config:
        ReshapeConfig {
            shape: Static(
                [
                    6,
                    4,
                ],
            ),
        }
    "#);
}

#[rstest]
fn selu(graph: &OnnxGraph) {
    let node = find_node(graph, "selu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Selu "selu1"
      Inputs:
        selu_input: F32[2, 3, 4]
      Outputs:
        selu1_out1: F32[2, 3, 4]
      Config:
        SeluConfig {
            alpha: 1.6732631921768188,
            gamma: 1.0507010221481323,
        }
    "#);
}

#[rstest]
fn shape(graph: &OnnxGraph) {
    let node = find_node(graph, "shape");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Shape "shape1"
      Inputs:
        shape_input: F32[2, 3, 4]
      Outputs:
        shape1_out1: Shape(3)
      Config:
        ShapeConfig {
            start: 0,
            end: 3,
        }
    "#);
}

#[rstest]
fn sigmoid(graph: &OnnxGraph) {
    let node = find_node(graph, "sigmoid");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sigmoid "sigmoid1"
      Inputs:
        sigmoid_input: F32[2, 3, 4]
      Outputs:
        sigmoid1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn size(graph: &OnnxGraph) {
    let node = find_node(graph, "size");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Size "size1"
      Inputs:
        size_input: F32[2, 3, 4]
      Outputs:
        size1_out1: Scalar(I64)
    "#);
}

#[rstest]
fn softplus(graph: &OnnxGraph) {
    let node = find_node(graph, "softplus");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Softplus "softplus1"
      Inputs:
        softplus_input: F32[2, 3, 4]
      Outputs:
        softplus1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn softsign(graph: &OnnxGraph) {
    let node = find_node(graph, "softsign");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Softsign "softsign1"
      Inputs:
        softsign_input: F32[2, 3, 4]
      Outputs:
        softsign1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn space_to_depth(graph: &OnnxGraph) {
    let node = find_node(graph, "spacetodepth");
    insta::assert_snapshot!(format!("{node}"), @r#"
    SpaceToDepth "spacetodepth1"
      Inputs:
        spacetodepth_input: F32[1, 2, 4, 4]
      Outputs:
        spacetodepth1_out1: F32[1, 8, 2, 2]
      Config:
        SpaceToDepthConfig {
            block_size: 2,
        }
    "#);
}

#[rstest]
fn sqrt(graph: &OnnxGraph) {
    let node = find_node(graph, "sqrt");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sqrt "sqrt1"
      Inputs:
        sqrt_input: F32[2, 3, 4]
      Outputs:
        sqrt1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn squeeze(graph: &OnnxGraph) {
    let node = find_node(graph, "squeeze");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Squeeze "squeeze1"
      Inputs:
        squeeze_input: F32[1, 3, 1, 4]
      Outputs:
        squeeze1_out1: F32[3, 4]
      Config:
        SqueezeConfig {
            axes: Some(
                Static(
                    [
                        0,
                        2,
                    ],
                ),
            ),
        }
    "#);
}

#[rstest]
fn tanh(graph: &OnnxGraph) {
    let node = find_node(graph, "tanh");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Tanh "tanh1"
      Inputs:
        tanh_input: F32[2, 3, 4]
      Outputs:
        tanh1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn top_k(graph: &OnnxGraph) {
    let node = find_node(graph, "topk");
    insta::assert_snapshot!(format!("{node}"), @r#"
    TopK "topk1"
      Inputs:
        topk_input: F32[3, 4]
      Outputs:
        topk1_out1: F32[?, ?]
        topk1_out2: I64[?, ?]
      Config:
        TopKConfig {
            axis: 1,
            k: Static(
                2,
            ),
        }
    "#);
}

#[rstest]
fn transpose(graph: &OnnxGraph) {
    let node = find_node(graph, "transpose");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Transpose "transpose1"
      Inputs:
        transpose_input: F32[2, 3, 4]
      Outputs:
        transpose1_out1: F32[4, 3, 2]
      Config:
        TransposeConfig {
            perm: [
                2,
                1,
                0,
            ],
        }
    "#);
}

#[rstest]
fn unsqueeze(graph: &OnnxGraph) {
    let node = find_node(graph, "unsqueeze");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Unsqueeze "unsqueeze1"
      Inputs:
        unsqueeze_input: F32[3, 4]
      Outputs:
        unsqueeze1_out1: F32[1, 3, 4, 1]
      Config:
        Static(
            [
                0,
                3,
            ],
        )
    "#);
}

#[rstest]
fn xor_op(graph: &OnnxGraph) {
    let node = find_node(graph, "xor");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Xor "xor1"
      Inputs:
        xor_a: Bool[2, 3, 4]
        xor_b: Bool[2, 3, 4]
      Outputs:
        xor1_out1: Bool[2, 3, 4]
    "#);
}

/// Ops that require min_opset > 1: Add, AveragePool, BatchNormalization, Div, Equal, Gemm, Greater, Hardmax, Less, LogSoftmax, Mean, Mul, Pad, Slice, Softmax, Split, Sub, Sum, Tile
#[test]
fn unsupported_ops_fail() {
    let result = load_model_result("opset_01_unsupported.onnx");
    assert!(result.is_err(), "expected parse failure for unsupported ops at opset 1");
}

