//! Opset 6 compliance tests.
//!
//! Auto-generated by gen_rust_tests.py. Edit the generator, not this file.

use super::helpers::*;
use rstest::*;

#[fixture]
#[once]
fn graph() -> OnnxGraph {
    load_model("opset_06.onnx")
}

#[rstest]
fn abs(graph: &OnnxGraph) {
    let node = find_node(graph, "abs");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Abs "abs1"
      Inputs:
        abs_input: F32[2, 3, 4]
      Outputs:
        abs1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn cast(graph: &OnnxGraph) {
    let node = find_node(graph, "cast");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Cast "cast1"
      Inputs:
        cast_input: F32[2, 3]
      Outputs:
        cast1_out1: I32[2, 3]
      Config:
        CastConfig {
            to: I32,
        }
    "#);
}

#[rstest]
fn ceil(graph: &OnnxGraph) {
    let node = find_node(graph, "ceil");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Ceil "ceil1"
      Inputs:
        ceil_input: F32[2, 3, 4]
      Outputs:
        ceil1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn clip(graph: &OnnxGraph) {
    let node = find_node(graph, "clip");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Clip "clip1"
      Inputs:
        clip_input: F32[2, 3, 4]
      Outputs:
        clip1_out1: F32[2, 3, 4]
      Config:
        ClipConfig {
            min: Some(
                Static(
                    0.0,
                ),
            ),
            max: Some(
                Static(
                    6.0,
                ),
            ),
        }
    "#);
}

/// Dropout is eliminated during post-processing (no-op).
/// Verify the model parses without error.
#[test]
fn dropout() {
    let _graph = load_model("opset_06.onnx");
}

#[rstest]
fn elu(graph: &OnnxGraph) {
    let node = find_node(graph, "elu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Elu "elu1"
      Inputs:
        elu_input: F32[2, 3, 4]
      Outputs:
        elu1_out1: F32[2, 3, 4]
      Config:
        EluConfig {
            alpha: 1.0,
        }
    "#);
}

#[rstest]
fn exp(graph: &OnnxGraph) {
    let node = find_node(graph, "exp");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Exp "exp1"
      Inputs:
        exp_input: F32[2, 3, 4]
      Outputs:
        exp1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn floor(graph: &OnnxGraph) {
    let node = find_node(graph, "floor");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Floor "floor1"
      Inputs:
        floor_input: F32[2, 3, 4]
      Outputs:
        floor1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn hard_sigmoid(graph: &OnnxGraph) {
    let node = find_node(graph, "hardsigmoid");
    insta::assert_snapshot!(format!("{node}"), @r#"
    HardSigmoid "hardsigmoid1"
      Inputs:
        hardsigmoid_input: F32[2, 3, 4]
      Outputs:
        hardsigmoid1_out1: F32[2, 3, 4]
      Config:
        HardSigmoidConfig {
            alpha: 0.2,
            beta: 0.5,
        }
    "#);
}

#[rstest]
fn instance_normalization(graph: &OnnxGraph) {
    let node = find_node(graph, "instancenormalization");
    insta::assert_snapshot!(format!("{node}"), @r#"
    InstanceNormalization "instancenormalization1"
      Inputs:
        instancenormalization_input: F32[1, 3, 4, 4]
        _: F32[3] [static(0)]
        _: F32[3] [static(1)]
      Outputs:
        instancenormalization1_out1: F32[1, 3, 4, 4]
      Config:
        InstanceNormConfig {
            epsilon: 9.999999747378752e-6,
        }
    "#);
}

#[rstest]
fn leaky_relu(graph: &OnnxGraph) {
    let node = find_node(graph, "leakyrelu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    LeakyRelu "leakyrelu1"
      Inputs:
        leakyrelu_input: F32[2, 3, 4]
      Outputs:
        leakyrelu1_out1: F32[2, 3, 4]
      Config:
        LeakyReluConfig {
            alpha: 0.009999999776482582,
        }
    "#);
}

#[rstest]
fn log(graph: &OnnxGraph) {
    let node = find_node(graph, "log");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Log "log1"
      Inputs:
        log_input: F32[2, 3, 4]
      Outputs:
        log1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn max(graph: &OnnxGraph) {
    let node = find_node(graph, "max");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Max "max1"
      Inputs:
        max_a: F32[2, 3, 4]
        max_b: F32[2, 3, 4]
      Outputs:
        max1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn min(graph: &OnnxGraph) {
    let node = find_node(graph, "min");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Min "min1"
      Inputs:
        min_a: F32[2, 3, 4]
        min_b: F32[2, 3, 4]
      Outputs:
        min1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn neg(graph: &OnnxGraph) {
    let node = find_node(graph, "neg");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Neg "neg1"
      Inputs:
        neg_input: F32[2, 3, 4]
      Outputs:
        neg1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn p_relu(graph: &OnnxGraph) {
    let node = find_node(graph, "prelu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    PRelu "prelu1"
      Inputs:
        prelu_input: F32[2, 3, 4]
        _: F32[1] [static(2)]
      Outputs:
        prelu1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn reciprocal(graph: &OnnxGraph) {
    let node = find_node(graph, "reciprocal");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Reciprocal "reciprocal1"
      Inputs:
        reciprocal_input: F32[2, 3, 4]
      Outputs:
        reciprocal1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn relu(graph: &OnnxGraph) {
    let node = find_node(graph, "relu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Relu "relu1"
      Inputs:
        relu_input: F32[2, 3, 4]
      Outputs:
        relu1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn selu(graph: &OnnxGraph) {
    let node = find_node(graph, "selu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Selu "selu1"
      Inputs:
        selu_input: F32[2, 3, 4]
      Outputs:
        selu1_out1: F32[2, 3, 4]
      Config:
        SeluConfig {
            alpha: 1.6732631921768188,
            gamma: 1.0507010221481323,
        }
    "#);
}

#[rstest]
fn sigmoid(graph: &OnnxGraph) {
    let node = find_node(graph, "sigmoid");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sigmoid "sigmoid1"
      Inputs:
        sigmoid_input: F32[2, 3, 4]
      Outputs:
        sigmoid1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn sqrt(graph: &OnnxGraph) {
    let node = find_node(graph, "sqrt");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sqrt "sqrt1"
      Inputs:
        sqrt_input: F32[2, 3, 4]
      Outputs:
        sqrt1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn tanh(graph: &OnnxGraph) {
    let node = find_node(graph, "tanh");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Tanh "tanh1"
      Inputs:
        tanh_input: F32[2, 3, 4]
      Outputs:
        tanh1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn tile(graph: &OnnxGraph) {
    let node = find_node(graph, "tile");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Tile "tile1"
      Inputs:
        tile_input: F32[2, 3]
        _: I64[2] [static(3)]
      Outputs:
        tile1_out1: F32[2, 3]
      Config:
        TileConfig {
            repeats: Static(
                [
                    2,
                    3,
                ],
            ),
        }
    "#);
}

/// Ops that require min_opset > 6: Add, BatchNormalization, Div, Gemm, Mean, Mul, Sub, Sum
#[test]
fn unsupported_ops_fail() {
    let result = load_model_result("opset_06_unsupported.onnx");
    assert!(result.is_err(), "expected parse failure for unsupported ops at opset 6");
}

