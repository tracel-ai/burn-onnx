//! Opset 14 compliance tests.
//!
//! Auto-generated by gen_rust_tests.py. Edit the generator, not this file.

use super::helpers::*;
use rstest::*;

#[fixture]
#[once]
fn graph() -> OnnxGraph {
    load_model("opset_14.onnx")
}

#[rstest]
fn add(graph: &OnnxGraph) {
    let node = find_node(graph, "add");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Add "add1"
      Inputs:
        add_a: F32[2, 3, 4]
        add_b: F32[2, 3, 4]
      Outputs:
        add1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn batch_normalization(graph: &OnnxGraph) {
    let node = find_node(graph, "batchnormalization");
    insta::assert_snapshot!(format!("{node}"), @r#"
    BatchNormalization "batchnormalization1"
      Inputs:
        batchnormalization_input: F32[1, 3, 4, 4]
        _: F32[3] [static(0)]
        _: F32[3] [static(1)]
        _: F32[3] [static(2)]
        _: F32[3] [static(3)]
      Outputs:
        batchnormalization1_out1: F32[1, 3, 4, 4]
      Config:
        Static(
            BatchNormStaticConfig {
                epsilon: 0.0,
                momentum: 0.0,
            },
        )
    "#);
}

#[rstest]
fn cum_sum(graph: &OnnxGraph) {
    let node = find_node(graph, "cumsum");
    insta::assert_snapshot!(format!("{node}"), @r#"
    CumSum "cumsum1"
      Inputs:
        cumsum_input: F32[2, 3]
        _: ScalarNative(I32) [static(4)]
      Outputs:
        cumsum1_out1: F32[2, 3]
      Config:
        CumSumConfig {
            axis: Static(
                1,
            ),
            exclusive: false,
            reverse: false,
        }
    "#);
}

#[rstest]
fn div(graph: &OnnxGraph) {
    let node = find_node(graph, "div");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Div "div1"
      Inputs:
        div_a: F32[2, 3, 4]
        div_b: F32[2, 3, 4]
      Outputs:
        div1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn gru(graph: &OnnxGraph) {
    let node = find_node(graph, "gru");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Gru "gru1"
      Inputs:
        gru_input: F32[1, 2, 3]
        _: F32[1, 12, 3] [static(5)]
        _: F32[1, 12, 4] [static(6)]
      Outputs:
        gru1_out1: F32[?, ?, ?, ?]
      Config:
        GruConfig {
            input_size: 3,
            hidden_size: 4,
            direction: Forward,
            has_bias: false,
            has_initial_h: false,
            batch_first: false,
            clip: None,
            linear_before_reset: false,
            gate_activation: Sigmoid,
            hidden_activation: Tanh,
            activation_alpha: None,
            activation_beta: None,
        }
    "#);
}

#[rstest]
fn hard_swish(graph: &OnnxGraph) {
    let node = find_node(graph, "hardswish");
    insta::assert_snapshot!(format!("{node}"), @r#"
    HardSwish "hardswish1"
      Inputs:
        hardswish_input: F32[2, 3, 4]
      Outputs:
        hardswish1_out1: F32[2, 3, 4]
    "#);
}

/// Identity is eliminated during post-processing (no-op).
/// Verify the model parses without error.
#[test]
fn identity() {
    let _graph = load_model("opset_14.onnx");
}

#[rstest]
fn lstm(graph: &OnnxGraph) {
    let node = find_node(graph, "lstm");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Lstm "lstm1"
      Inputs:
        lstm_input: F32[1, 2, 3]
        _: F32[1, 16, 3] [static(7)]
        _: F32[1, 16, 4] [static(8)]
      Outputs:
        lstm1_out1: F32[?, ?, ?, ?]
      Config:
        LstmConfig {
            input_size: 3,
            hidden_size: 4,
            direction: Forward,
            has_bias: false,
            has_initial_h: false,
            has_initial_c: false,
            has_peephole: false,
            batch_first: false,
            clip: None,
            input_forget: false,
            gate_activation: Sigmoid,
            cell_activation: Tanh,
            hidden_activation: Tanh,
        }
    "#);
}

#[rstest]
fn mul(graph: &OnnxGraph) {
    let node = find_node(graph, "mul");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Mul "mul1"
      Inputs:
        mul_a: F32[2, 3, 4]
        mul_b: F32[2, 3, 4]
      Outputs:
        mul1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn relu(graph: &OnnxGraph) {
    let node = find_node(graph, "relu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Relu "relu1"
      Inputs:
        relu_input: F32[2, 3, 4]
      Outputs:
        relu1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn reshape(graph: &OnnxGraph) {
    let node = find_node(graph, "reshape");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Reshape "reshape1"
      Inputs:
        reshape_input: F32[2, 3, 4]
        _: I64[2] [static(9)]
      Outputs:
        reshape1_out1: F32[6, 4]
      Config:
        ReshapeConfig {
            shape: Static(
                [
                    6,
                    4,
                ],
            ),
        }
    "#);
}

#[rstest]
fn sub(graph: &OnnxGraph) {
    let node = find_node(graph, "sub");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Sub "sub1"
      Inputs:
        sub_a: F32[2, 3, 4]
        sub_b: F32[2, 3, 4]
      Outputs:
        sub1_out1: F32[2, 3, 4]
    "#);
}

#[rstest]
fn trilu(graph: &OnnxGraph) {
    let node = find_node(graph, "trilu");
    insta::assert_snapshot!(format!("{node}"), @r#"
    Trilu "trilu1"
      Inputs:
        trilu_input: F32[3, 4]
      Outputs:
        trilu1_out1: F32[3, 4]
      Config:
        TriluConfig {
            upper: true,
            diagonal: 0,
        }
    "#);
}
